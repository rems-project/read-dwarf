<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (read-dwarf.index)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ read-dwarf</nav><h1 id="read-dwarf"><a href="#read-dwarf" class="anchor"></a>read-dwarf</h1><p>read-dwarf is a tool for exploring, symbolically executing and validating ELF binaries generated from C, using DWARF debugging information. It will be used to perform translation validation between O0 and O2 binaries. It is written in OCaml and relies on many other tools. Its current set of features allows a user to explore binaries with the source code inlined, and for simple cases, symbolically evaluate a function, check two versions of the same function (compiled at O0 and O2 optimisation levels) evaluate to the same machine state (given a simulation relation) and compute branch tables for indirect jumps. We intend to build upon this foundation of features to handle all more functions, by incorporating information from higher-levels, inferring types and pointer-provenance, inferring simulation relations automatically, and supporting concurrency models for Arm v8.</p><p>This documentation is for the internal code of read-dwarf.</p><nav class="toc"><ul><li><a href="#overview">Overview</a></li><li><a href="#detailed-pages">Detailed pages</a></li><li><a href="#dependencies">Dependencies</a></li><li><a href="#alphabetical-index">Alphabetical index</a></li></ul></nav></header><h2 id="overview"><a href="#overview" class="anchor"></a>Overview</h2><p>Currently read-dwarf does not yet have the actual infrastructure to find a simulation relation between two binaries, however it already has all the necessary infrastructure to run symbolicaly a binary through any control flow path, and infer the C type along the way. The exact C-like type-system used is a bit more advanced than C.</p><p>I'll attempt here to give a pipeline overview of what happens when you want to run a function symbolically. All of this is done by the <a href="Run/Func/index.html"><code>Run.Func</code></a> module that provide a CLI to run a single function symbolically.</p><ul><li>The binary is parsed by the linksem library using the <a href="Elf/index.html"><code>Elf</code></a> and <a href="Dw/index.html"><code>Dw</code></a> modules. In this phase C-Type linking happens as described in <a href="Ctype/index.html#ctyplink"><span>C type linking: From Linksem</span></a></li><li>The function name is found and used in the <a href="Dw/Func/index.html"><code>Dw.Func</code></a> format.</li><li>The API and ABI of the function are computed according to the current achitecture. The generic <a href="Architecture.html"><code>Architecture</code></a> interface is defined in the virtual module <a href="Sig/index.html"><code>Sig</code></a> but the only implementation is in <code>src/arch/aarch64/sig.ml</code> (<a href="https://github.com/ocaml/dune/commit/1ce94b47e9640419bb7e644d6da1e0f53e9b23d9">dune doesn't build docs for virtual module implementations :(</a>).</li><li>If we suppose the instruction caches are empty, the <a href="Isla/Server/index.html"><code>Isla.Server</code></a> will be started and used by <a href="Run/Init/index.html"><code>Run.Init</code></a> to fetch the machine initial <a href="State/index.html"><code>State</code></a>. This will call <code>isla</code> to get the trace of the <code>nop</code> instruction. See <a href="InstructionPipeline.html"><code>InstructionPipeline</code></a></li><li>The function entry <a href="State/index.html"><code>State</code></a> can be computed from the machine initial state and the ABI.</li><li>We load the symbolic execution engine <a href="Run/Runner/index.html"><code>Run.Runner</code></a> with the DWARF information and initialize it.</li><li>We create a <a href="Run/Block/index.html"><code>Run.Block</code></a> which is a piece of code that can run a delimited block of code. We give to it the end conditions provided by the command line like potential breakpoints. Then we run it.</li><li>The <a href="Run/Block/index.html"><code>Run.Block</code></a> calls the <a href="Run/Runner/index.html"><code>Run.Runner</code></a> on each instruction as needed to move forward and build the tree (<a href="State/Tree/index.html"><code>State.Tree</code></a>) of possible states. For each instruction, the whole <a href="InstructionPipeline.html"><code>InstructionPipeline</code></a> is run to generate a set of <a href="Trace/index.html"><code>Trace</code></a>s and this set of traces is run on a <a href="State/index.html"><code>State</code></a> to get the next state. See <a href="SymbolicExecution.html"><code>SymbolicExecution</code></a>.</li><li>Then we pretty print the results using <a href="Utils/Pp/index.html"><code>Utils.Pp</code></a> and <a href="Utils/Logs/index.html"><code>Utils.Logs</code></a>. See <a href="Printing.html"><code>Printing</code></a></li></ul><h2 id="detailed-pages"><a href="#detailed-pages" class="anchor"></a>Detailed pages</h2><p>Here is a list of top-level pages that each explains a subgroup of functionality:</p><ul><li><a href="Architecture.html"><code>Architecture</code></a>: All modules related to achitecture representation</li><li><a href="BinaryAnalysis.html"><code>BinaryAnalysis</code></a>: All modules about reading ELF and DWARF information</li><li><a href="CLI.html"><code>CLI</code></a>: All modules defining the command line interfaces.</li><li><a href="Configuration.html"><code>Configuration</code></a>: Configuration organisation</li><li><a href="InstructionPipeline.html"><code>InstructionPipeline</code></a>: All modules related to instruction semantics processing.</li><li><a href="Printing.html"><code>Printing</code></a>: Generic information about printing and logging</li><li><a href="SymbolicExecution.html"><code>SymbolicExecution</code></a>: All modules related to top-level symbolic execution.</li><li><a href="SymbolicExpressions.html"><code>SymbolicExpressions</code></a>: All modules related to symbolic expression manipulation</li><li><a href="TypeInference.html"><code>TypeInference</code></a>: All modules about the C type system and type inference.</li><li><a href="Utilities.html"><code>Utilities</code></a>: List of modules that provide generic functionality</li></ul><h2 id="dependencies"><a href="#dependencies" class="anchor"></a>Dependencies</h2><p>Here is a list of the dependency libraries that are used, and links to their documentation (for those that have some).</p><ul><li><code>linksem</code> : ELF and DWARF Parser and analyzer</li><li><code>isla-lang</code>: Isla traces parser</li><li><a href="https://erratique.ch/software/cmdliner/doc/Cmdliner"><code>cmdliner</code></a>: Library to parse the command line.</li><li><a href="http://cambium.inria.fr/~fpottier/pprint/doc/pprint/PPrint/index.html"><code>pprint</code></a>: Pretty-printing library. Use it via the <a href="Utils/Pp/index.html"><code>Utils.Pp</code></a> module.</li><li><a href="https://antoinemine.github.io/Zarith/doc/latest/index.html"><code>zarith</code></a>: Big integer library. Used by <code>linksem</code> and all <code>linksem</code> interacting modules, and by <a href="Utils/BitVec/index.html"><code>Utils.BitVec</code></a>.</li><li><a href="http://mmottl.github.io/res/api/res/"><code>res</code></a>: Resizable array. Use it via the <code>Vec</code> module</li><li><a href="http://ocamlgraph.lri.fr/doc/"><code>ocamlgraph</code></a>: Graph library. Only used in <a href="Analyse/index.html"><code>Analyse</code></a> for now; may be used elsewhere later.</li><li><a href="http://ocaml-toml.github.io/To.ml/"><code>toml</code></a> Toml Parsing library. Only used in <a href="Config/File/index.html"><code>Config.File</code></a> to parse the config file. It should not be used elsewhere.</li><li><a href="https://erratique.ch/software/uutf/doc/Uutf"><code>uutf</code></a> : Unicode library. Only used to do UTF-8 character folding in <a href="Analyse/index.html"><code>Analyse</code></a>. Those utility function should probably move to <a href="Utils/String/index.html"><code>Utils.String</code></a> to be accessible elsewhere.</li></ul><h2 id="alphabetical-index"><a href="#alphabetical-index" class="anchor"></a>Alphabetical index</h2><p>Here is an alphabetical list of all modules, except <code>src/arch/aarch64/sig.ml</code>.</p><ul class="modules"><li><a href="Analyse/index.html"><code>Analyse</code></a></li><li><a href="Arch/index.html"><code>Arch</code></a></li><li><a href="Ast/index.html"><code>Ast</code></a></li><li><a href="BranchTable/index.html"><code>BranchTable</code></a></li><li><a href="Config/index.html"><code>Config</code></a></li><li><a href="Ctype/index.html"><code>Ctype</code></a></li><li><a href="Dw/index.html"><code>Dw</code></a></li><li><a href="Elf/index.html"><code>Elf</code></a></li><li><a href="Exp/index.html"><code>Exp</code></a></li><li><a href="AstGen/index.html"><code>AstGen</code></a></li><li><a href="Isla/index.html"><code>Isla</code></a></li><li><a href="Other_cmds/index.html"><code>Other_cmds</code></a></li><li><a href="Run/index.html"><code>Run</code></a></li><li><a href="Simrel/index.html"><code>Simrel</code></a></li><li><a href="State/index.html"><code>State</code></a></li><li><a href="Tests/index.html"><code>Tests</code></a></li><li><a href="Trace/index.html"><code>Trace</code></a></li><li><a href="Utils/index.html"><code>Utils</code></a></li><li><a href="Z3/index.html"><code>Z3</code></a></li></ul></div></body></html>