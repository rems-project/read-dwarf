<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ctype (read-dwarf.Ctype)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">read-dwarf</a> &#x00BB; Ctype</nav><h1>Module <code>Ctype</code></h1><p>This module provides the internal C-like type system. This type system is slightly different than the normal C type system. This module only provides the Ocaml datastructure to represent those types. The typing rules are implemented in <span class="xref-unresolved" title="unresolved reference to &quot;Trace.Typer&quot;"><a href="../Trace/index.html"><code>Trace</code></a>.Typer</span>, where they are applied dire</p><p>These types follow the normal C type structure except for pointers that are more complex. To handle the fact that the C compiler knows perfectly the ABI and is &quot;allowed&quot; to used it, we have to make pointer types resist manual adjusting of pointers to point to the field of a struct. However the new pointer cannot just have type <code>field_type*</code> because one could want to get back a pointer to the whole structure by subtracting an offset from the field pointer. Thus a pointer must never forget information about its surroundings. Those surroundings are called a <a href="index.html#type-fragment"><code>fragment</code></a> and represent all the type information of the fragment of memory in which a pointer lies. The pointer is thus represented as a fragment of memory and an offset. Since the pointer type is more complex and packs more information, the surface syntax has changed. A pointer type is written between braces, so <code>A*</code> becomes <code>{A}</code>, but in more complex cases, all informations fit between the braces.</p><p>Furthermore, the fragment part of the pointer does not record any information about aliasing: two different type fragments are perfectly allowed to alias. To handle non-aliasing properties, like the stack not aliasing the heap or restrict pointers, pointers also have a <code>provenance</code> field. See <a href="../State/Mem/index.html"><code>State.Mem</code></a>.</p><p>There is another problem: The C language does not define a C type system for the whole program, contrary to C++. It defines only a type system per compilation unit. This limitation is too annoying to work with so the module implements some kind of linking of types, similar to C++ rules. See <a href="index.html#ctyplink"><span>C type linking: From Linksem</span></a>.</p><nav class="toc"><ul><li><a href="#dwarf-constants">DWARF constants</a></li><li><a href="#types">Types</a></li><li><a href="#comparisons">Comparisons</a></li><li><a href="#convenience-manipulation">Convenience manipulation</a></li><li><a href="#sizeof">Sizeof</a></li><li><a href="#ctyplink">C type linking: From Linksem</a></li><li><a href="#pretty-printing">Pretty printing</a></li><li><a href="#type-at">Type at</a></li></ul></nav></header><section><header><h2 id="dwarf-constants"><a href="#dwarf-constants" class="anchor"></a>DWARF constants</h2></header><dl><dt class="spec value" id="val-vDW_ATE_address"><a href="#val-vDW_ATE_address" class="anchor"></a><code><span class="keyword">val</span> vDW_ATE_address : int</code></dt><dt class="spec value" id="val-vDW_ATE_boolean"><a href="#val-vDW_ATE_boolean" class="anchor"></a><code><span class="keyword">val</span> vDW_ATE_boolean : int</code></dt><dt class="spec value" id="val-vDW_ATE_signed"><a href="#val-vDW_ATE_signed" class="anchor"></a><code><span class="keyword">val</span> vDW_ATE_signed : int</code></dt><dt class="spec value" id="val-vDW_ATE_signed_char"><a href="#val-vDW_ATE_signed_char" class="anchor"></a><code><span class="keyword">val</span> vDW_ATE_signed_char : int</code></dt><dt class="spec value" id="val-vDW_ATE_unsigned"><a href="#val-vDW_ATE_unsigned" class="anchor"></a><code><span class="keyword">val</span> vDW_ATE_unsigned : int</code></dt><dt class="spec value" id="val-vDW_ATE_unsigned_char"><a href="#val-vDW_ATE_unsigned_char" class="anchor"></a><code><span class="keyword">val</span> vDW_ATE_unsigned_char : int</code></dt></dl></section><section><header><h2 id="types"><a href="#types" class="anchor"></a>Types</h2></header><dl><dt class="spec type" id="type-provenance"><a href="#type-provenance" class="anchor"></a><code><span class="keyword">type</span> provenance</code><code> = </code><table class="variant"><tr id="type-provenance.Restricted" class="anchored"><td class="def constructor"><a href="#type-provenance.Restricted" class="anchor"></a><code>| </code><code><span class="constructor">Restricted</span> <span class="keyword">of</span> int</code></td></tr><tr id="type-provenance.Main" class="anchored"><td class="def constructor"><a href="#type-provenance.Main" class="anchor"></a><code>| </code><code><span class="constructor">Main</span></code></td></tr></table></dt><dd><p>This is the provenance of the pointer. This tells to which symbolic memory block a pointer points to. To get the full explanation, go to <a href="../State/Mem/index.html"><code>State.Mem</code></a></p></dd></dl><dl><dt class="spec value" id="val-pp_provenance"><a href="#val-pp_provenance" class="anchor"></a><code><span class="keyword">val</span> pp_provenance : <a href="index.html#type-provenance">provenance</a> <span>&#45;&gt;</span> <a href="../Utils/index.html#module-Pp">Utils.Pp</a>.document</code></dt></dl><dl><dt class="spec type" id="type-unqualified"><a href="#type-unqualified" class="anchor"></a><code><span class="keyword">type</span> unqualified</code><code> = </code><table class="variant"><tr id="type-unqualified.Machine" class="anchored"><td class="def constructor"><a href="#type-unqualified.Machine" class="anchor"></a><code>| </code><code><span class="constructor">Machine</span> <span class="keyword">of</span> int</code></td><td class="doc"><p>Size in bytes for now</p></td></tr><tr id="type-unqualified.Cint" class="anchored"><td class="def constructor"><a href="#type-unqualified.Cint" class="anchor"></a><code>| </code><code><span class="constructor">Cint</span> <span class="keyword">of</span> </code><code>{</code><table class="record"><tr id="type-unqualified.name" class="anchored"><td class="def field"><a href="#type-unqualified.name" class="anchor"></a><code>name : string;</code></td></tr><tr id="type-unqualified.signed" class="anchored"><td class="def field"><a href="#type-unqualified.signed" class="anchor"></a><code>signed : bool;</code></td></tr><tr id="type-unqualified.size" class="anchored"><td class="def field"><a href="#type-unqualified.size" class="anchor"></a><code>size : int;</code></td></tr><tr id="type-unqualified.ischar" class="anchored"><td class="def field"><a href="#type-unqualified.ischar" class="anchor"></a><code>ischar : bool;</code></td></tr></table><code>}</code></td></tr><tr id="type-unqualified.Cbool" class="anchored"><td class="def constructor"><a href="#type-unqualified.Cbool" class="anchor"></a><code>| </code><code><span class="constructor">Cbool</span></code></td></tr><tr id="type-unqualified.Ptr" class="anchored"><td class="def constructor"><a href="#type-unqualified.Ptr" class="anchor"></a><code>| </code><code><span class="constructor">Ptr</span> <span class="keyword">of</span> </code><code>{</code><table class="record"><tr id="type-unqualified.fragment" class="anchored"><td class="def field"><a href="#type-unqualified.fragment" class="anchor"></a><code>fragment : <a href="index.html#type-fragment">fragment</a>;</code></td></tr><tr id="type-unqualified.offset" class="anchored"><td class="def field"><a href="#type-unqualified.offset" class="anchor"></a><code>offset : <a href="index.html#type-offset">offset</a>;</code></td></tr><tr id="type-unqualified.provenance" class="anchored"><td class="def field"><a href="#type-unqualified.provenance" class="anchor"></a><code>provenance : <a href="index.html#type-provenance">provenance</a>;</code></td></tr></table><code>}</code></td><td class="doc"><p><code>fragment</code> is about a type fragment. <code>offset</code> is the position in that type fragment. <code>provenance</code> is about a runtime symbolic block (see <a href="../State/Mem/index.html"><code>State.Mem</code></a>).</p></td></tr><tr id="type-unqualified.Struct" class="anchored"><td class="def constructor"><a href="#type-unqualified.Struct" class="anchor"></a><code>| </code><code><span class="constructor">Struct</span> <span class="keyword">of</span> </code><code>{</code><table class="record"><tr id="type-unqualified.name" class="anchored"><td class="def field"><a href="#type-unqualified.name" class="anchor"></a><code>name : string;</code></td></tr><tr id="type-unqualified.size" class="anchored"><td class="def field"><a href="#type-unqualified.size" class="anchor"></a><code>size : int;</code></td></tr><tr id="type-unqualified.id" class="anchored"><td class="def field"><a href="#type-unqualified.id" class="anchor"></a><code>id : int;</code></td></tr></table><code>}</code></td><td class="doc"><p>See <a href="index.html#type-env"><code>env</code></a> for what the id refers to. The int is the size</p></td></tr><tr id="type-unqualified.Array" class="anchored"><td class="def constructor"><a href="#type-unqualified.Array" class="anchor"></a><code>| </code><code><span class="constructor">Array</span> <span class="keyword">of</span> </code><code>{</code><table class="record"><tr id="type-unqualified.elem" class="anchored"><td class="def field"><a href="#type-unqualified.elem" class="anchor"></a><code>elem : <a href="index.html#type-t">t</a>;</code></td></tr><tr id="type-unqualified.dims" class="anchored"><td class="def field"><a href="#type-unqualified.dims" class="anchor"></a><code>dims : <span><span>int option</span> list</span>;</code></td></tr></table><code>}</code></td></tr><tr id="type-unqualified.Enum" class="anchored"><td class="def constructor"><a href="#type-unqualified.Enum" class="anchor"></a><code>| </code><code><span class="constructor">Enum</span> <span class="keyword">of</span> </code><code>{</code><table class="record"><tr id="type-unqualified.name" class="anchored"><td class="def field"><a href="#type-unqualified.name" class="anchor"></a><code>name : string;</code></td></tr><tr id="type-unqualified.id" class="anchored"><td class="def field"><a href="#type-unqualified.id" class="anchor"></a><code>id : int;</code></td></tr></table><code>}</code></td><td class="doc"><p>See <a href="index.html#type-env"><code>env</code></a> for what the id refers to</p></td></tr><tr id="type-unqualified.FuncPtr" class="anchored"><td class="def constructor"><a href="#type-unqualified.FuncPtr" class="anchor"></a><code>| </code><code><span class="constructor">FuncPtr</span></code></td><td class="doc"><p>Hack to accommodate PKVM</p></td></tr><tr id="type-unqualified.Missing" class="anchored"><td class="def constructor"><a href="#type-unqualified.Missing" class="anchor"></a><code>| </code><code><span class="constructor">Missing</span></code></td><td class="doc"><p>Hack to accommodate PKVM</p></td></tr></table></dt><dd><p>The unqualified part of the C type without const volatile, ...</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">and</span> t</code><code> = </code><code>{</code><table class="record"><tr id="type-t.unqualified" class="anchored"><td class="def field"><a href="#type-t.unqualified" class="anchor"></a><code>unqualified : <a href="index.html#type-unqualified">unqualified</a>;</code></td></tr><tr id="type-t.const" class="anchored"><td class="def field"><a href="#type-t.const" class="anchor"></a><code>const : bool;</code></td></tr><tr id="type-t.volatile" class="anchored"><td class="def field"><a href="#type-t.volatile" class="anchor"></a><code>volatile : bool;</code></td></tr><tr id="type-t.restrict" class="anchored"><td class="def field"><a href="#type-t.restrict" class="anchor"></a><code>restrict : bool;</code></td></tr><tr id="type-t.constexpr" class="anchored"><td class="def field"><a href="#type-t.constexpr" class="anchor"></a><code>constexpr : bool;</code></td></tr></table><code>}</code></dt><dd><p>The internal representation of generalized C types</p></dd></dl><dl><dt class="spec type" id="type-fragment"><a href="#type-fragment" class="anchor"></a><code><span class="keyword">and</span> fragment</code><code> = </code><table class="variant"><tr id="type-fragment.Unknown" class="anchored"><td class="def constructor"><a href="#type-fragment.Unknown" class="anchor"></a><code>| </code><code><span class="constructor">Unknown</span></code></td><td class="doc"><p>Unknown type, But without possibility of learning</p></td></tr><tr id="type-fragment.Single" class="anchored"><td class="def constructor"><a href="#type-fragment.Single" class="anchor"></a><code>| </code><code><span class="constructor">Single</span> <span class="keyword">of</span> <a href="index.html#type-t">t</a></code></td><td class="doc"><p>Single object: Only when accessing of a global variable</p></td></tr><tr id="type-fragment.DynArray" class="anchored"><td class="def constructor"><a href="#type-fragment.DynArray" class="anchor"></a><code>| </code><code><span class="constructor">DynArray</span> <span class="keyword">of</span> <a href="index.html#type-t">t</a></code></td><td class="doc"><p>Generic C pointer, may point to multiple element of that type</p></td></tr><tr id="type-fragment.DynFragment" class="anchored"><td class="def constructor"><a href="#type-fragment.DynFragment" class="anchor"></a><code>| </code><code><span class="constructor">DynFragment</span> <span class="keyword">of</span> int</code></td><td class="doc"><p>Writable fragment for memory whose type is changing dynamically</p></td></tr><tr id="type-fragment.Global" class="anchored"><td class="def constructor"><a href="#type-fragment.Global" class="anchor"></a><code>| </code><code><span class="constructor">Global</span></code></td><td class="doc"><p>The Global fragment that contains all the fixed ELF section .text, .data, .rodata, ...</p></td></tr></table></dt><dd><p>The type of a memory fragment</p></dd></dl><dl><dt class="spec type" id="type-offset"><a href="#type-offset" class="anchor"></a><code><span class="keyword">and</span> offset</code><code> = </code><table class="variant"><tr id="type-offset.Const" class="anchored"><td class="def constructor"><a href="#type-offset.Const" class="anchor"></a><code>| </code><code><span class="constructor">Const</span> <span class="keyword">of</span> int</code></td><td class="doc"><p>Constant offset</p></td></tr><tr id="type-offset.Somewhere" class="anchored"><td class="def constructor"><a href="#type-offset.Somewhere" class="anchor"></a><code>| </code><code><span class="constructor">Somewhere</span></code></td></tr></table></dt><dd><p>The type of an offset in a fragment</p></dd></dl><dl><dt class="spec type" id="type-linksem_t"><a href="#type-linksem_t" class="anchor"></a><code><span class="keyword">type</span> linksem_t</code><code> = Dwarf.c_type</code></dt><dd><p>The type of C types in Linksem</p></dd></dl><dl><dt class="spec type" id="type-field"><a href="#type-field" class="anchor"></a><code><span class="keyword">type</span> field</code><code> = </code><code>{</code><table class="record"><tr id="type-field.fname" class="anchored"><td class="def field"><a href="#type-field.fname" class="anchor"></a><code>fname : <span>string option</span>;</code></td></tr><tr id="type-field.offset" class="anchored"><td class="def field"><a href="#type-field.offset" class="anchor"></a><code>offset : int;</code></td></tr><tr id="type-field.typ" class="anchored"><td class="def field"><a href="#type-field.typ" class="anchor"></a><code>typ : <a href="index.html#type-t">t</a>;</code></td></tr><tr id="type-field.size" class="anchored"><td class="def field"><a href="#type-field.size" class="anchor"></a><code>size : int;</code></td></tr></table><code>}</code></dt><dd><p>A field in a structure</p></dd></dl><dl><dt class="spec type" id="type-linksem_field"><a href="#type-linksem_field" class="anchor"></a><code><span class="keyword">type</span> linksem_field</code><code> = <span><a href="index.html#type-linksem_t">linksem_t</a> Dwarf.struct_union_member</span></code></dt></dl><dl><dt class="spec module" id="module-FieldMap"><a href="#module-FieldMap" class="anchor"></a><code><span class="keyword">module</span> <a href="FieldMap/index.html">FieldMap</a> : <a href="../Utils/RngMap/index.html#module-type-S">Utils.RngMap.S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../Utils/RngMap/module-type-S/index.html#type-obj">obj</a> = <a href="index.html#type-field">field</a></code></dt><dd><p>A range map over field to represent a structure layout</p></dd></dl><dl><dt class="spec type" id="type-struc"><a href="#type-struc" class="anchor"></a><code><span class="keyword">type</span> struc</code><code> = </code><code>{</code><table class="record"><tr id="type-struc.layout" class="anchored"><td class="def field"><a href="#type-struc.layout" class="anchor"></a><code>layout : <a href="FieldMap/index.html#type-t">FieldMap.t</a>;</code></td></tr><tr id="type-struc.name" class="anchored"><td class="def field"><a href="#type-struc.name" class="anchor"></a><code>name : string;</code></td></tr><tr id="type-struc.size" class="anchored"><td class="def field"><a href="#type-struc.size" class="anchor"></a><code>size : int;</code></td></tr><tr id="type-struc.complete" class="anchored"><td class="def field"><a href="#type-struc.complete" class="anchor"></a><code>complete : bool;</code></td></tr></table><code>}</code></dt><dd><p>The type of a C structure.</p><p>A structure can be complete or incomplete but due to some internal hackery this is a need for a subtle difference with C: Even incomplete structure have a size, they just don't have any field.</p><p>A incomplete struct can and will often be complete later as the interpretation of DWARF information advances.</p><p>The name field is the linking name of the struct.</p></dd></dl><dl><dt class="spec type" id="type-enum"><a href="#type-enum" class="anchor"></a><code><span class="keyword">type</span> enum</code><code> = </code><code>{</code><table class="record"><tr id="type-enum.name" class="anchored"><td class="def field"><a href="#type-enum.name" class="anchor"></a><code>name : string;</code></td></tr><tr id="type-enum.labels" class="anchored"><td class="def field"><a href="#type-enum.labels" class="anchor"></a><code>labels : <span><span>(int, <span>string option</span>)</span> Stdlib.Hashtbl.t</span>;</code></td></tr></table><code>}</code></dt><dd><p>The representation type of a C enumeration</p></dd></dl><dl><dt class="spec type" id="type-cupdie_id"><a href="#type-cupdie_id" class="anchor"></a><code><span class="keyword">type</span> cupdie_id</code><code> = int * int</code></dt><dd><p>The identifier for a linksem_cupdie. See <a href="index.html#val-ids_of_cupdie"><code>ids_of_cupdie</code></a></p></dd></dl><dl><dt class="spec type" id="type-linksem_env"><a href="#type-linksem_env" class="anchor"></a><code><span class="keyword">type</span> linksem_env</code><code> = <span><a href="index.html#type-linksem_t">linksem_t</a> list</span></code></dt><dd><p>The type of environement linksem gives us.</p><p>Only structs, enums and unions can appear. A type can appear multiple times and also be forward-declared with missing data like size. <a href="index.html#val-env_of_linksem"><code>env_of_linksem</code></a> hopefully deals with all those problems</p></dd></dl><dl><dt class="spec type" id="type-linksem_indexed_env"><a href="#type-linksem_indexed_env" class="anchor"></a><code><span class="keyword">type</span> linksem_indexed_env</code><code> = <span><span>(<a href="index.html#type-cupdie_id">cupdie_id</a>, <a href="index.html#type-linksem_t">linksem_t</a>)</span> Stdlib.Hashtbl.t</span></code></dt><dd><p>An version of the linksem environement indexed by <a href="index.html#type-cupdie_id"><code>cupdie_id</code></a></p></dd></dl><dl><dt class="spec type" id="type-env"><a href="#type-env" class="anchor"></a><code><span class="keyword">type</span> env</code><code> = </code><code>{</code><table class="record"><tr id="type-env.structs" class="anchored"><td class="def field"><a href="#type-env.structs" class="anchor"></a><code>structs : <span><span>(string, <a href="index.html#type-struc">struc</a>)</span> <a href="../Utils/IdMap/index.html#type-t">Utils.IdMap.t</a></span>;</code></td></tr><tr id="type-env.enums" class="anchored"><td class="def field"><a href="#type-env.enums" class="anchor"></a><code>enums : <span><span>(string, <a href="index.html#type-enum">enum</a>)</span> <a href="../Utils/IdMap/index.html#type-t">Utils.IdMap.t</a></span>;</code></td></tr><tr id="type-env.lenv" class="anchored"><td class="def field"><a href="#type-env.lenv" class="anchor"></a><code>lenv : <a href="index.html#type-linksem_indexed_env">linksem_indexed_env</a>;</code></td></tr></table><code>}</code></dt><dd><p>The type environment that contain mapping from linking name and a generated id</p><p>to the actual content of structs and enumerations.</p><p>Linking names can be:</p><ul><li>A plain name for a struct/enum declared with a tag.</li><li><code>typedef.name</code> for an unnamed struct declared in a typedef</li><li><code>outer.member</code> for unnamed struct used as the type of a <code>member</code> of a struct with linking name <code>outer</code>.</li></ul><p>As an unnamed struct can be declared in the linksem environement but used with the typedef only after the initial environement setup of <a href="index.html#val-env_of_linksem"><code>env_of_linksem</code></a>, the original linksem type must be kept alive in <code>lenv</code></p></dd></dl><dl><dt class="spec value" id="val-ptr_size"><a href="#val-ptr_size" class="anchor"></a><code><span class="keyword">val</span> ptr_size : int</code></dt><dd><p>The size of pointer. This will be configurable later</p></dd></dl><dl><dt class="spec value" id="val-enum_size"><a href="#val-enum_size" class="anchor"></a><code><span class="keyword">val</span> enum_size : int</code></dt><dd><p>The size of enums. This will be configurable later</p></dd></dl></section><section><header><h2 id="comparisons"><a href="#comparisons" class="anchor"></a>Comparisons</h2></header><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt></dl></section><section><header><h2 id="convenience-manipulation"><a href="#convenience-manipulation" class="anchor"></a>Convenience manipulation</h2></header><dl><dt class="spec value" id="val-is_struct"><a href="#val-is_struct" class="anchor"></a><code><span class="keyword">val</span> is_struct : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_array"><a href="#val-is_array" class="anchor"></a><code><span class="keyword">val</span> is_array : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_ptr"><a href="#val-is_ptr" class="anchor"></a><code><span class="keyword">val</span> is_ptr : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_scalar"><a href="#val-is_scalar" class="anchor"></a><code><span class="keyword">val</span> is_scalar : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_composite"><a href="#val-is_composite" class="anchor"></a><code><span class="keyword">val</span> is_composite : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_constexpr"><a href="#val-is_constexpr" class="anchor"></a><code><span class="keyword">val</span> is_constexpr : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-ptr"><a href="#val-ptr" class="anchor"></a><code><span class="keyword">val</span> ptr : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-unqualified">unqualified</a></code></dt><dd><p>Make a simple pointer from a type</p></dd></dl><dl><dt class="spec value" id="val-voidstar"><a href="#val-voidstar" class="anchor"></a><code><span class="keyword">val</span> voidstar : <a href="index.html#type-unqualified">unqualified</a></code></dt><dd><p>A void* pointer</p></dd></dl><dl><dt class="spec value" id="val-qual"><a href="#val-qual" class="anchor"></a><code><span class="keyword">val</span> qual : <span>?&#8288;const:bool</span> <span>&#45;&gt;</span> <span>?&#8288;volatile:bool</span> <span>&#45;&gt;</span> <span>?&#8288;restrict:bool</span> <span>&#45;&gt;</span> <span>?&#8288;constexpr:bool</span> <span>&#45;&gt;</span> <a href="index.html#type-unqualified">unqualified</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Create a qualified type from an unqualified type with the specified qualifiers</p></dd></dl><dl><dt class="spec value" id="val-add_qual"><a href="#val-add_qual" class="anchor"></a><code><span class="keyword">val</span> add_qual : <span>?&#8288;const:bool</span> <span>&#45;&gt;</span> <span>?&#8288;volatile:bool</span> <span>&#45;&gt;</span> <span>?&#8288;restrict:bool</span> <span>&#45;&gt;</span> <span>?&#8288;constexpr:bool</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>update specified qualifiers. Other qualifier are kept</p></dd></dl><dl><dt class="spec value" id="val-machine"><a href="#val-machine" class="anchor"></a><code><span class="keyword">val</span> machine : <span>?&#8288;constexpr:bool</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Create a machine type of that size without qualifiers</p></dd></dl><dl><dt class="spec value" id="val-of_frag"><a href="#val-of_frag" class="anchor"></a><code><span class="keyword">val</span> of_frag : <span>?&#8288;provenance:<a href="index.html#type-provenance">provenance</a></span> <span>&#45;&gt;</span> <span>?&#8288;offset:int</span> <span>&#45;&gt;</span> <span>?&#8288;constexpr:bool</span> <span>&#45;&gt;</span> <span>?&#8288;restrict:bool</span> <span>&#45;&gt;</span> <a href="index.html#type-fragment">fragment</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Create a pointer to fragment with specified offset (0 by default)</p></dd></dl><dl><dt class="spec value" id="val-of_frag_somewhere"><a href="#val-of_frag_somewhere" class="anchor"></a><code><span class="keyword">val</span> of_frag_somewhere : <span>?&#8288;provenance:<a href="index.html#type-provenance">provenance</a></span> <span>&#45;&gt;</span> <span>?&#8288;constexpr:bool</span> <span>&#45;&gt;</span> <span>?&#8288;restrict:bool</span> <span>&#45;&gt;</span> <a href="index.html#type-fragment">fragment</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Create a pointer to fragment Somewhere</p></dd></dl><dl><dt class="spec value" id="val-incomplete_struct"><a href="#val-incomplete_struct" class="anchor"></a><code><span class="keyword">val</span> incomplete_struct : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-struc">struc</a></code></dt><dd><p>Build an incomplete struct with a linking name and a size</p></dd></dl><dl><dt class="spec value" id="val-make_env"><a href="#val-make_env" class="anchor"></a><code><span class="keyword">val</span> make_env : <a href="index.html#type-linksem_indexed_env">linksem_indexed_env</a> <span>&#45;&gt;</span> <a href="index.html#type-env">env</a></code></dt><dd><p>Makes an empty environement from and indexed linksem environement</p></dd></dl><dl><dt class="spec value" id="val-offset_update"><a href="#val-offset_update" class="anchor"></a><code><span class="keyword">val</span> offset_update : <a href="index.html#type-offset">offset</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-offset">offset</a></code></dt><dd><p>Update an <a href="index.html#type-offset"><code>offset</code></a> with an integer update</p></dd></dl><dl><dt class="spec value" id="val-ptr_update"><a href="#val-ptr_update" class="anchor"></a><code><span class="keyword">val</span> ptr_update : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Update an pointer with an integer update</p></dd></dl><dl><dt class="spec value" id="val-ptr_set"><a href="#val-ptr_set" class="anchor"></a><code><span class="keyword">val</span> ptr_set : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Set a arbitrary new offset in a pointer</p></dd></dl><dl><dt class="spec value" id="val-ptr_forget"><a href="#val-ptr_forget" class="anchor"></a><code><span class="keyword">val</span> ptr_forget : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Make a pointer forget it's offset</p></dd></dl></section><section><header><h2 id="sizeof"><a href="#sizeof" class="anchor"></a>Sizeof</h2><p>This section give implementation of sizeof function.</p><p>Dynamic array have size 0 until we are able to deal with C99 last member dynamic arrays. This will mess up with <a href="index.html#val-type_at"><code>type_at</code></a>. TODO fix it.</p></header><dl><dt class="spec value" id="val-sizeof_unqualified"><a href="#val-sizeof_unqualified" class="anchor"></a><code><span class="keyword">val</span> sizeof_unqualified : <a href="index.html#type-unqualified">unqualified</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Give the size of an <a href="index.html#type-unqualified"><code>unqualified</code></a> type. Need the environement.</p></dd></dl><dl><dt class="spec value" id="val-sizeof"><a href="#val-sizeof" class="anchor"></a><code><span class="keyword">val</span> sizeof : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Give the size of an type. Need the environement.</p></dd></dl><dl><dt class="spec value" id="val-len"><a href="#val-len" class="anchor"></a><code><span class="keyword">val</span> len : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>For being used in <span class="xref-unresolved" title="unresolved reference to &quot;RngMap.LenObject&quot;"><code>RngMap</code>.LenObject</span></p></dd></dl></section><section><header><h2 id="ctyplink"><a href="#ctyplink" class="anchor"></a>C type linking: From Linksem</h2><p>This section contain the whole hierarchy of function used to convert type from DWARF representation to the internal type system.</p><p>During this conversion, C type linking happens. This means that structure with the same name from different compilation unit are identified as being the same. If they do not have the same layout, an error is raised. This would mean that either the C program does very weird thing with it's type that we don't want to verify or more likely that it is ill-formed. As we have to deal with anonymous struct, name are a bit more complex than plain <code>struct</code> tags. See <a href="index.html#type-env"><code>env</code></a> for a description.</p><p>The top-level interface for types is <a href="index.html#val-of_linksem"><code>of_linksem</code></a> and the top-level interface for environement is <a href="index.html#val-env_of_linksem"><code>env_of_linksem</code></a>. Those will be called by <a href="../Dw/index.html"><code>Dw</code></a> at DWARF loading time to generate a coherent type system.</p></header><dl><dt class="spec type" id="type-conversion_context"><a href="#type-conversion_context" class="anchor"></a><code><span class="keyword">type</span> conversion_context</code><code> = </code><code>{</code><table class="record"><tr id="type-conversion_context.env" class="anchored"><td class="def field"><a href="#type-conversion_context.env" class="anchor"></a><code>env : <a href="index.html#type-env">env</a>;</code></td></tr><tr id="type-conversion_context.potential_link_name" class="anchored"><td class="def field"><a href="#type-conversion_context.potential_link_name" class="anchor"></a><code>potential_link_name : <span>string option</span>;</code></td></tr></table><code>}</code></dt><dd><p>This type is a conversion context.</p><p>Its role is to contain all the things that all the functions in this section will need to convert types.</p></dd></dl><dl><dt class="spec value" id="val-ids_of_cupdie"><a href="#val-ids_of_cupdie" class="anchor"></a><code><span class="keyword">val</span> ids_of_cupdie : Dwarf.cupdie <span>&#45;&gt;</span> <a href="index.html#type-cupdie_id">cupdie_id</a></code></dt><dd><p>Get the id of a linksem <code>cupdie</code></p></dd></dl><dl><dt class="spec value" id="val-pp_decl"><a href="#val-pp_decl" class="anchor"></a><code><span class="keyword">val</span> pp_decl : Dwarf.decl <span>&#45;&gt;</span> PPrintEngine.document</code></dt><dd><p>Pretty print the dwarf decl type</p><p>TODO: Move that in the appropriate place</p></dd></dl><dl><dt class="spec exception" id="exception-LinkError"><a href="#exception-LinkError" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">LinkError</span></code></dt><dd><p>This exception is raised when the type we are trying to reach must came from another translation unit or later in the current one.</p><p>The information is incomplete at this moment to create is.</p><p>Normally this exception should only happen during the initial <a href="index.html#val-env_of_linksem"><code>env_of_linksem</code></a>. If it happens elsewhere, either the code used an anonymous struct that do not have C++-like linkage or the compiler did not do its job.</p></dd></dl><dl><dt class="spec value" id="val-expect_some_link"><a href="#val-expect_some_link" class="anchor"></a><code><span class="keyword">val</span> expect_some_link : <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-base_type_of_linksem"><a href="#val-base_type_of_linksem" class="anchor"></a><code><span class="keyword">val</span> base_type_of_linksem : <span>?&#8288;size:Z.t</span> <span>&#45;&gt;</span> <span>encoding:Z.t</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-unqualified">unqualified</a></code></dt><dd><p>Convert a base type with a name and encoding and maybe a size to its inner representation</p><p>Only integers, chars and bools supported. No floating points</p></dd></dl><dl><dt class="spec value" id="val-field_of_linksem"><a href="#val-field_of_linksem" class="anchor"></a><code><span class="keyword">val</span> field_of_linksem : <span>cc:<a href="index.html#type-conversion_context">conversion_context</a></span> <span>&#45;&gt;</span> <a href="index.html#type-linksem_field">linksem_field</a> <span>&#45;&gt;</span> <a href="FieldMap/index.html#type-obj">FieldMap.obj</a></code></dt><dt class="spec value" id="val-field_map_of_linksem"><a href="#val-field_map_of_linksem" class="anchor"></a><code><span class="keyword">val</span> field_map_of_linksem : string <span>&#45;&gt;</span> <span>cc:<a href="index.html#type-conversion_context">conversion_context</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-linksem_field">linksem_field</a> list</span> <span>&#45;&gt;</span> <a href="FieldMap/index.html#type-t">FieldMap.t</a></code></dt><dt class="spec value" id="val-struc_of_linksem"><a href="#val-struc_of_linksem" class="anchor"></a><code><span class="keyword">val</span> struc_of_linksem : <span>cc:<a href="index.html#type-conversion_context">conversion_context</a></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><a href="index.html#type-linksem_field">linksem_field</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-struc">struc</a></code></dt><dt class="spec value" id="val-struct_type_of_linksem"><a href="#val-struct_type_of_linksem" class="anchor"></a><code><span class="keyword">val</span> struct_type_of_linksem : <span>?&#8288;force_complete:bool</span> <span>&#45;&gt;</span> <span>cc:<a href="index.html#type-conversion_context">conversion_context</a></span> <span>&#45;&gt;</span> <span>cupdie:Dwarf.cupdie</span> <span>&#45;&gt;</span> <span>mname:<span>string option</span></span> <span>&#45;&gt;</span> <span>decl:Dwarf.decl</span> <span>&#45;&gt;</span> <a href="index.html#type-unqualified">unqualified</a></code></dt><dd><p>Build a struct from it's cupdie and name. If <code>force_complete</code> is true and the struct is incomplete. It will try to complete is using <code>cupdie</code> and throw <a href="index.html#exception-LinkError"><code>LinkError</code></a> if it fails.</p></dd></dl><dl><dt class="spec value" id="val-enum_of_linksem"><a href="#val-enum_of_linksem" class="anchor"></a><code><span class="keyword">val</span> enum_of_linksem : <span>cc:<a href="index.html#type-conversion_context">conversion_context</a></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span>Dwarf.enumeration_member list</span> <span>&#45;&gt;</span> <a href="index.html#type-enum">enum</a></code></dt><dt class="spec value" id="val-enum_type_of_linksem"><a href="#val-enum_type_of_linksem" class="anchor"></a><code><span class="keyword">val</span> enum_type_of_linksem : <span>cc:<a href="index.html#type-conversion_context">conversion_context</a></span> <span>&#45;&gt;</span> <span>cupdie:Dwarf.cupdie</span> <span>&#45;&gt;</span> <span>mname:<span>string option</span></span> <span>&#45;&gt;</span> <span>decl:Dwarf.decl</span> <span>&#45;&gt;</span> <a href="index.html#type-unqualified">unqualified</a></code></dt><dt class="spec value" id="val-unqualified_of_linksem"><a href="#val-unqualified_of_linksem" class="anchor"></a><code><span class="keyword">val</span> unqualified_of_linksem : <span>?&#8288;force_complete:bool</span> <span>&#45;&gt;</span> <span>cc:<a href="index.html#type-conversion_context">conversion_context</a></span> <span>&#45;&gt;</span> <a href="index.html#type-linksem_t">linksem_t</a> <span>&#45;&gt;</span> <a href="index.html#type-unqualified">unqualified</a></code></dt><dd><p>Convert an unqualified type. Union are just <code>Machine n</code> where n is their size</p></dd></dl><dl><dt class="spec value" id="val-of_linksem_none"><a href="#val-of_linksem_none" class="anchor"></a><code><span class="keyword">val</span> of_linksem_none : unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Placeholder for whatever the right thing to do is when linksem found no type - TODO: fix</p></dd></dl><dl><dt class="spec value" id="val-of_linksem_cc"><a href="#val-of_linksem_cc" class="anchor"></a><code><span class="keyword">val</span> of_linksem_cc : <span>?&#8288;force_complete:bool</span> <span>&#45;&gt;</span> <span>cc:<a href="index.html#type-conversion_context">conversion_context</a></span> <span>&#45;&gt;</span> <span>?&#8288;const:bool</span> <span>&#45;&gt;</span> <span>?&#8288;volatile:bool</span> <span>&#45;&gt;</span> <span>?&#8288;restrict:bool</span> <span>&#45;&gt;</span> <a href="index.html#type-linksem_t">linksem_t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>The main <code>of_linksem</code> that take a full conversion_context and qualifiers.</p><p>The user friendly version is <a href="index.html#val-of_linksem"><code>of_linksem</code></a></p><p>See <a href="index.html#val-struct_type_of_linksem"><code>struct_type_of_linksem</code></a> for the explanation of <code>force_complete</code>.</p><p>All the qualifier passed as parameter are added to the resulting type.</p></dd></dl><dl><dt class="spec value" id="val-of_linksem"><a href="#val-of_linksem" class="anchor"></a><code><span class="keyword">val</span> of_linksem : <span>env:<a href="index.html#type-env">env</a></span> <span>&#45;&gt;</span> <a href="index.html#type-linksem_t">linksem_t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>The user friendly interface that convert a type using the environment. This useful when there is no additional linking information to pass on</p></dd></dl><dl><dt class="spec value" id="val-env_of_linksem"><a href="#val-env_of_linksem" class="anchor"></a><code><span class="keyword">val</span> env_of_linksem : <a href="index.html#type-linksem_env">linksem_env</a> <span>&#45;&gt;</span> <a href="index.html#type-env">env</a></code></dt><dd><p>The main environment conversion function.</p><p>This the function that deal with all the type linking process, forward declaration an all that stuff.</p><p>First it create the indexed linksem environment (member lenv of <a href="index.html#type-env"><code>env</code></a>),</p><p>Then it registers all named structs as incomplete in the environment (to deal with self recursion, only named structs can self-recurse).</p><p>Finally it run <a href="index.html#val-of_linksem_cc"><code>of_linksem_cc</code></a> on all the types with <code>force_complete</code> on. During this phase it ignore all <a href="index.html#exception-LinkError"><code>LinkError</code></a> that arise. It assumes that if some thing was incomplete at that point, it will become complete later.</p><p>Then it can return the freshly built environment.</p><p>If some structs are still incomplete, but are actually used, the <a href="index.html#exception-LinkError"><code>LinkError</code></a> will be raised at the time of use.</p></dd></dl></section><section><header><h2 id="pretty-printing"><a href="#pretty-printing" class="anchor"></a>Pretty printing</h2></header><dl><dt class="spec value" id="val-pp_signed"><a href="#val-pp_signed" class="anchor"></a><code><span class="keyword">val</span> pp_signed : bool <span>&#45;&gt;</span> PPrintEngine.document</code></dt><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Utils/index.html#module-Pp">Utils.Pp</a>.document</code></dt><dd><p>Pretty print a type. If an environement is provided, structs and enums will be printed with a name, otherwise they will just have a number</p></dd></dl><dl><dt class="spec value" id="val-pp_unqualified"><a href="#val-pp_unqualified" class="anchor"></a><code><span class="keyword">val</span> pp_unqualified : <a href="index.html#type-unqualified">unqualified</a> <span>&#45;&gt;</span> <a href="../Utils/index.html#module-Pp">Utils.Pp</a>.document</code></dt><dt class="spec value" id="val-pp_fragment"><a href="#val-pp_fragment" class="anchor"></a><code><span class="keyword">val</span> pp_fragment : <a href="index.html#type-fragment">fragment</a> <span>&#45;&gt;</span> <a href="../Utils/index.html#module-Pp">Utils.Pp</a>.document</code></dt><dt class="spec value" id="val-pp_offset"><a href="#val-pp_offset" class="anchor"></a><code><span class="keyword">val</span> pp_offset : <a href="index.html#type-offset">offset</a> <span>&#45;&gt;</span> <a href="../Utils/index.html#module-Pp">Utils.Pp</a>.document</code></dt><dt class="spec value" id="val-pp_arr"><a href="#val-pp_arr" class="anchor"></a><code><span class="keyword">val</span> pp_arr : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span>int option</span> list</span> <span>&#45;&gt;</span> <a href="../Utils/index.html#module-Pp">Utils.Pp</a>.document</code></dt><dt class="spec value" id="val-pp_arr_dim"><a href="#val-pp_arr_dim" class="anchor"></a><code><span class="keyword">val</span> pp_arr_dim : <span>int option</span> <span>&#45;&gt;</span> <a href="../Utils/index.html#module-Pp">Utils.Pp</a>.document</code></dt><dt class="spec value" id="val-pp_field"><a href="#val-pp_field" class="anchor"></a><code><span class="keyword">val</span> pp_field : <a href="index.html#type-field">field</a> <span>&#45;&gt;</span> PPrintEngine.document</code></dt><dt class="spec value" id="val-pp_struct"><a href="#val-pp_struct" class="anchor"></a><code><span class="keyword">val</span> pp_struct : <a href="index.html#type-struc">struc</a> <span>&#45;&gt;</span> <a href="../Utils/index.html#module-Pp">Utils.Pp</a>.document</code></dt><dt class="spec value" id="val-pp_enums"><a href="#val-pp_enums" class="anchor"></a><code><span class="keyword">val</span> pp_enums : <a href="index.html#type-enum">enum</a> <span>&#45;&gt;</span> <a href="../Utils/index.html#module-Pp">Utils.Pp</a>.document</code></dt><dt class="spec value" id="val-pp_env"><a href="#val-pp_env" class="anchor"></a><code><span class="keyword">val</span> pp_env : <a href="index.html#type-env">env</a> <span>&#45;&gt;</span> <a href="../Utils/index.html#module-Pp">Utils.Pp</a>.document</code></dt><dd><p>Print the whole environement (not the linksem indexed environment)</p></dd></dl></section><section><header><h2 id="type-at"><a href="#type-at" class="anchor"></a>Type at</h2><p>This section is about getting the type at a specific offset in things.</p></header><dl><dt class="spec value" id="val-struct_at"><a href="#val-struct_at" class="anchor"></a><code><span class="keyword">val</span> struct_at : <span>env:<a href="index.html#type-env">env</a></span> <span>&#45;&gt;</span> <span>size:int</span> <span>&#45;&gt;</span> <a href="index.html#type-struc">struc</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="../Utils/index.html#module-Option">Utils.Option</a>.t</span></code></dt><dd><p>Same as <a href="index.html#val-type_at"><code>type_at</code></a> but for structs</p></dd></dl><dl><dt class="spec value" id="val-type_at"><a href="#val-type_at" class="anchor"></a><code><span class="keyword">val</span> type_at : <span>env:<a href="index.html#type-env">env</a></span> <span>&#45;&gt;</span> <span>size:int</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="../Utils/index.html#module-Option">Utils.Option</a>.t</span></code></dt><dd><p>Get the type of size <code>size</code> at the provided offset in another type</p></dd></dl></section></div></body></html>