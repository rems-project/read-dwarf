<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Utils__BitVec (read-dwarf.Utils__BitVec)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">read-dwarf</a> &#x00BB; Utils__BitVec</nav><h1>Module <code>Utils__BitVec</code></h1><p>This module provides an interface for a bit vector of dynamic size.</p><p>For now this is entirely based on <code>zarith</code>.</p><p>TODO: It could be nice to export this as a separate library on opam at some point</p><p>The value of type t is semantically pure and can be compare with polymorphic operators. It will compare the size first, then the value.</p><p>The size of bit vectors must always be strictly positive.</p><nav class="toc"><ul><li><a href="#integer-conversions">Integer conversions</a></li><li><a href="#bytes-conversions">Bytes conversions</a></li><li><a href="#string-conversions,-printing">String conversions, printing</a></li><li><a href="#arithmetic">Arithmetic</a></li><li><a href="#bit-manipulation">Bit manipulation</a></li><li><a href="#infix-operators">Infix operators</a></li></ul></nav></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>The type of a bitvector</p></dd></dl><dl><dt class="spec exception" id="exception-SizeMismatch"><a href="#exception-SizeMismatch" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">SizeMismatch</span> <span class="keyword">of</span> int * int</code></dt><dd><p>Raise when the runtime size do not match on operation that require so (like <a href="index.html#val-add"><code>add</code></a>)</p></dd></dl><dl><dt class="spec value" id="val-size"><a href="#val-size" class="anchor"></a><code><span class="keyword">val</span> size : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>The size of the bitvector</p></dd></dl><dl><dt class="spec value" id="val-zero"><a href="#val-zero" class="anchor"></a><code><span class="keyword">val</span> zero : <span>size:int</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>The bitvector representing 0 of specified size</p></dd></dl><dl><dt class="spec value" id="val-one"><a href="#val-one" class="anchor"></a><code><span class="keyword">val</span> one : <span>size:int</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>The bitvector representing 1 of specified size</p></dd></dl><dl><dt class="spec value" id="val-minus_one"><a href="#val-minus_one" class="anchor"></a><code><span class="keyword">val</span> minus_one : <span>size:int</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>The bitvector representing -1 of specified size</p></dd></dl><section><header><h2 id="integer-conversions"><a href="#integer-conversions" class="anchor"></a>Integer conversions</h2></header><dl><dt class="spec value" id="val-to_z"><a href="#val-to_z" class="anchor"></a><code><span class="keyword">val</span> to_z : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Z.t</code></dt><dd><p>To a signed big integer</p></dd></dl><dl><dt class="spec value" id="val-to_uz"><a href="#val-to_uz" class="anchor"></a><code><span class="keyword">val</span> to_uz : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Z.t</code></dt><dd><p>To an unsigned big integer</p></dd></dl><dl><dt class="spec value" id="val-of_z"><a href="#val-of_z" class="anchor"></a><code><span class="keyword">val</span> of_z : <span>size:int</span> <span>&#45;&gt;</span> Z.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Of bit integer. Wrapped modulo <code>2^size</code>.</p></dd></dl><dl><dt class="spec value" id="val-to_int"><a href="#val-to_int" class="anchor"></a><code><span class="keyword">val</span> to_int : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>To a signed integer. Fail if it doesn't fit</p></dd></dl><dl><dt class="spec value" id="val-to_uint"><a href="#val-to_uint" class="anchor"></a><code><span class="keyword">val</span> to_uint : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>To an unsigned integer. Fail if it doesn't fit without wrapping i.e the result is still positive</p></dd></dl><dl><dt class="spec value" id="val-of_int"><a href="#val-of_int" class="anchor"></a><code><span class="keyword">val</span> of_int : <span>size:int</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Of integer. Wrapped modulo <code>size</code>.</p></dd></dl><dl><dt class="spec value" id="val-to_bool"><a href="#val-to_bool" class="anchor"></a><code><span class="keyword">val</span> to_bool : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Convert a one size bitvector to bool. Throw <a href="index.html#exception-SizeMismatch"><code>SizeMismatch</code></a> if the bitvector is not one-sized</p></dd></dl><dl><dt class="spec value" id="val-of_bool"><a href="#val-of_bool" class="anchor"></a><code><span class="keyword">val</span> of_bool : bool <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Create a one-sized bitvector representing the boolean</p></dd></dl></section><section><header><h2 id="bytes-conversions"><a href="#bytes-conversions" class="anchor"></a>Bytes conversions</h2></header><dl><dt class="spec value" id="val-to_bytes"><a href="#val-to_bytes" class="anchor"></a><code><span class="keyword">val</span> to_bytes : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bytes</code></dt><dd><p>Return the shortest bytes that represent the bitvector in little-endian. There may be extra bits (if size is not a multiple of 8) which are zeros.</p><p>This bytes may be shorter that the bitvector size, for example the bitvector 1 of size 64bits, will still be returned by this function as a single byte 1. For another behavior, see <a href="index.html#val-to_bytes_exact"><code>to_bytes_exact</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-to_bytes_exact"><a href="#val-to_bytes_exact" class="anchor"></a><code><span class="keyword">val</span> to_bytes_exact : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bytes</code></dt><dd><p>Return a bytes representation of mininal length to encompass the whole bitvector size. Extra bits (if size is not a multiple of 8) are zeros.</p></dd></dl><dl><dt class="spec value" id="val-bytes_store"><a href="#val-bytes_store" class="anchor"></a><code><span class="keyword">val</span> bytes_store : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Store the bitvector in the bytes at the specified offset in little endian. The bitvector size must be a multiple of 8 or <code>Invalid_argument</code> is thrown</p></dd></dl><dl><dt class="spec value" id="val-of_bytes"><a href="#val-of_bytes" class="anchor"></a><code><span class="keyword">val</span> of_bytes : <span>size:int</span> <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Read a bitvector from a bytes data (little endian)</p></dd></dl><dl><dt class="spec value" id="val-bytes_load"><a href="#val-bytes_load" class="anchor"></a><code><span class="keyword">val</span> bytes_load : <span>size:int</span> <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Load a bitvector of <code>size</code> bits from the bytes at the specified offset (little endian). <code>size</code> must be a multiple of 8 or <code>Invalid_argument</code> is thrown</p></dd></dl></section><section><header><h2 id="string-conversions,-printing"><a href="#string-conversions,-printing" class="anchor"></a>String conversions, printing</h2></header><dl><dt class="spec value" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span class="keyword">val</span> of_string : <span>?&#8288;base:int</span> <span>&#45;&gt;</span> <span>size:int</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Parse a string with specified <code>base</code> (10 if unspecified) and return a bitvector of size <code>size</code>. If the string is too big, the integer is still parsed and then wrapped modulo <code>2^size</code></p></dd></dl><dl><dt class="spec value" id="val-of_substring"><a href="#val-of_substring" class="anchor"></a><code><span class="keyword">val</span> of_substring : <span>?&#8288;base:int</span> <span>&#45;&gt;</span> <span>size:int</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> <span>len:int</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Same as <a href="index.html#val-of_string"><code>of_string</code></a> but on the substring starting at <code>pos</code> of length <code>len</code>.</p></dd></dl><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : <span>?&#8288;base:int</span> <span>&#45;&gt;</span> <span>?&#8288;unsigned:bool</span> <span>&#45;&gt;</span> <span>?&#8288;force_width:bool</span> <span>&#45;&gt;</span> <span>?&#8288;prefix:bool</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Convert the value to a string representation in the specified <code>base</code>.</p><p><code>base</code> can only be 2, 8, 10 or 16, otherwise the function fails.</p><p>Set <code>unsigned</code> to true to have unsigned values (signed by default).</p><p>Set <code>prefix</code> to true to have the <code>0x/0o/0b</code> prefix (no prefix by default)</p><p>Set <code>force_width</code> to false to not have a digit length matching the bitvector length, otherwise leading zeros will be inserted to match the length.</p></dd></dl><dl><dt class="spec value" id="val-of_smt"><a href="#val-of_smt" class="anchor"></a><code><span class="keyword">val</span> of_smt : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Convert a bitvector in the SMTLib format to a <a href="index.html#type-t"><code>t</code></a></p></dd></dl><dl><dt class="spec value" id="val-to_smt"><a href="#val-to_smt" class="anchor"></a><code><span class="keyword">val</span> to_smt : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Convert a bitvector to the SMTLib format</p></dd></dl><dl><dt class="spec value" id="val-pp_smt"><a href="#val-pp_smt" class="anchor"></a><code><span class="keyword">val</span> pp_smt : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Utils/index.html#module-Pp">Utils.Pp</a>.document</code></dt><dd><p>Print a bitvector with the SMTLib format</p></dd></dl></section><section><header><h2 id="arithmetic"><a href="#arithmetic" class="anchor"></a>Arithmetic</h2></header><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val</span> add : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Add the values. Result is of the same size as the inputs.</p><p>Throw <a href="index.html#exception-SizeMismatch"><code>SizeMismatch</code></a> if sizes differ</p></dd></dl><dl><dt class="spec value" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span class="keyword">val</span> sub : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Subtract the values. Result is of the same size as the inputs.</p><p>Throw <a href="index.html#exception-SizeMismatch"><code>SizeMismatch</code></a> if sizes differ</p></dd></dl><dl><dt class="spec value" id="val-neg"><a href="#val-neg" class="anchor"></a><code><span class="keyword">val</span> neg : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Negate the value. Wrap if the value is the smaller integer (It will stay the smallest integer)</p></dd></dl><dl><dt class="spec value" id="val-mul"><a href="#val-mul" class="anchor"></a><code><span class="keyword">val</span> mul : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Multiply the values. Result is of the same size as the inputs.</p><p>Throw <a href="index.html#exception-SizeMismatch"><code>SizeMismatch</code></a> if sizes differ</p></dd></dl><dl><dt class="spec value" id="val-sdiv"><a href="#val-sdiv" class="anchor"></a><code><span class="keyword">val</span> sdiv : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Divide the values as signed integers. Result is of the same size as the inputs.</p><p>It rounds the result toward zero.</p><p>Throw <a href="index.html#exception-SizeMismatch"><code>SizeMismatch</code></a> if sizes differ.</p><p>Throw <code>Division_by_zero</code> if there is a division by zero.</p></dd></dl><dl><dt class="spec value" id="val-srem"><a href="#val-srem" class="anchor"></a><code><span class="keyword">val</span> srem : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Take the remainder of the signed division. Result is of the same size as the inputs.</p><p><code> a = sdiv a b * b + srem a b </code></p><p>Throw <a href="index.html#exception-SizeMismatch"><code>SizeMismatch</code></a> if sizes differ.</p><p>Throw <code>Division_by_zero</code> if there is a division by zero.</p></dd></dl><dl><dt class="spec value" id="val-smod"><a href="#val-smod" class="anchor"></a><code><span class="keyword">val</span> smod : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Take the signed modulo. The result has the sign of the divisor. Result is of the same size as the inputs.</p><p>Throw <a href="index.html#exception-SizeMismatch"><code>SizeMismatch</code></a> if sizes differ.</p><p>Throw <code>Division_by_zero</code> if there is a division by zero.</p></dd></dl><dl><dt class="spec value" id="val-udiv"><a href="#val-udiv" class="anchor"></a><code><span class="keyword">val</span> udiv : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Divide the values as unsigned integers. Result is of the same size as the inputs.</p><p>Throw <a href="index.html#exception-SizeMismatch"><code>SizeMismatch</code></a> if sizes differ</p><p>Throw <code>Division_by_zero</code> if there is a division by zero.</p></dd></dl><dl><dt class="spec value" id="val-urem"><a href="#val-urem" class="anchor"></a><code><span class="keyword">val</span> urem : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Get the remainder of the unsigned division. Result if of the same size as the inputs.</p><p><code> a = udiv a b * b + urem a b </code></p><p>Throw <a href="index.html#exception-SizeMismatch"><code>SizeMismatch</code></a> if sizes differ</p><p>Throw <code>Division_by_zero</code> if there is a division by zero.</p></dd></dl></section><section><header><h2 id="bit-manipulation"><a href="#bit-manipulation" class="anchor"></a>Bit manipulation</h2></header><dl><dt class="spec value" id="val-logand"><a href="#val-logand" class="anchor"></a><code><span class="keyword">val</span> logand : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Bitwise and of the values. Result is of the same size as the inputs.</p><p>Throw <a href="index.html#exception-SizeMismatch"><code>SizeMismatch</code></a> if sizes differ</p></dd></dl><dl><dt class="spec value" id="val-logor"><a href="#val-logor" class="anchor"></a><code><span class="keyword">val</span> logor : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Bitwise or of the values. Result is of the same size as the inputs.</p><p>Throw <a href="index.html#exception-SizeMismatch"><code>SizeMismatch</code></a> if sizes differ</p></dd></dl><dl><dt class="spec value" id="val-logxor"><a href="#val-logxor" class="anchor"></a><code><span class="keyword">val</span> logxor : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Bitwise xor of the values. Result is of the same size as the inputs.</p><p>Throw <a href="index.html#exception-SizeMismatch"><code>SizeMismatch</code></a> if sizes differ</p></dd></dl><dl><dt class="spec value" id="val-lognot"><a href="#val-lognot" class="anchor"></a><code><span class="keyword">val</span> lognot : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Bitwise not of the value. Result is of the same size as the input.</p></dd></dl><dl><dt class="spec value" id="val-redor"><a href="#val-redor" class="anchor"></a><code><span class="keyword">val</span> redor : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Do an or of all the bits in the bitvector</p></dd></dl><dl><dt class="spec value" id="val-redand"><a href="#val-redand" class="anchor"></a><code><span class="keyword">val</span> redand : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Do an and of all the bits in the bitvector</p></dd></dl><dl><dt class="spec value" id="val-shift_left"><a href="#val-shift_left" class="anchor"></a><code><span class="keyword">val</span> shift_left : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Do a left shift. The second argument must be non-negative</p></dd></dl><dl><dt class="spec value" id="val-shift_left_bv"><a href="#val-shift_left_bv" class="anchor"></a><code><span class="keyword">val</span> shift_left_bv : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Same as <a href="index.html#val-shift_left"><code>shift_left</code></a> but the second argument is also a bitvector of any size interpreted as unsigned</p></dd></dl><dl><dt class="spec value" id="val-shift_right_arith"><a href="#val-shift_right_arith" class="anchor"></a><code><span class="keyword">val</span> shift_right_arith : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Do an arithmetic right shift (copy the sign bit). The second argument must be non-negative</p></dd></dl><dl><dt class="spec value" id="val-shift_right_arith_bv"><a href="#val-shift_right_arith_bv" class="anchor"></a><code><span class="keyword">val</span> shift_right_arith_bv : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Same as <a href="index.html#val-shift_right_arith"><code>shift_right_arith</code></a> but the second argument is also a bitvector of any size interpreted as unsigned</p></dd></dl><dl><dt class="spec value" id="val-shift_right_logic"><a href="#val-shift_right_logic" class="anchor"></a><code><span class="keyword">val</span> shift_right_logic : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Do an logical right shift (insert zeroes). The second argument must be non-negative</p></dd></dl><dl><dt class="spec value" id="val-shift_right_logic_bv"><a href="#val-shift_right_logic_bv" class="anchor"></a><code><span class="keyword">val</span> shift_right_logic_bv : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Same as <a href="index.html#val-shift_right_logic"><code>shift_right_logic</code></a> but the second argument is also a bitvector of any size interpreted as unsigned</p></dd></dl><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val</span> concat : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Concatenates the bitvectors</p></dd></dl><dl><dt class="spec value" id="val-extract"><a href="#val-extract" class="anchor"></a><code><span class="keyword">val</span> extract : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>extract bv a b</code> extract bits <code>a</code> to <code>b</code> included from <code>bv</code>. Indices start at 0</p></dd></dl><dl><dt class="spec value" id="val-zero_extend"><a href="#val-zero_extend" class="anchor"></a><code><span class="keyword">val</span> zero_extend : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Add the second argument of zeroes to the left</p></dd></dl><dl><dt class="spec value" id="val-sign_extend"><a href="#val-sign_extend" class="anchor"></a><code><span class="keyword">val</span> sign_extend : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Copy the bit sign as much as specified by the integer on the left</p></dd></dl></section><section><header><h2 id="infix-operators"><a href="#infix-operators" class="anchor"></a>Infix operators</h2><p>Divisions do not have any operators because signed and unsigned division have different semantics</p></header><dl><dt class="spec value" id="val-(+)"><a href="#val-(+)" class="anchor"></a><code><span class="keyword">val</span> (+) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><a href="index.html#val-add"><code>add</code></a></p></dd></dl><dl><dt class="spec value" id="val-(-)"><a href="#val-(-)" class="anchor"></a><code><span class="keyword">val</span> (-) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><a href="index.html#val-sub"><code>sub</code></a></p></dd></dl><dl><dt class="spec value" id="val-(*)"><a href="#val-(*)" class="anchor"></a><code><span class="keyword">val</span> (*) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><a href="index.html#val-mul"><code>mul</code></a></p></dd></dl><dl><dt class="spec value" id="val-(~-)"><a href="#val-(~-)" class="anchor"></a><code><span class="keyword">val</span> (~-) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><a href="index.html#val-neg"><code>neg</code></a></p></dd></dl><dl><dt class="spec value" id="val-(lsl)"><a href="#val-(lsl)" class="anchor"></a><code><span class="keyword">val</span> (lsl) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><a href="index.html#val-shift_left_bv"><code>shift_left_bv</code></a></p></dd></dl><dl><dt class="spec value" id="val-asl"><a href="#val-asl" class="anchor"></a><code><span class="keyword">val</span> asl : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><a href="index.html#val-shift_left_bv"><code>shift_left_bv</code></a></p></dd></dl><dl><dt class="spec value" id="val-(lsr)"><a href="#val-(lsr)" class="anchor"></a><code><span class="keyword">val</span> (lsr) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><a href="index.html#val-shift_right_logic_bv"><code>shift_right_logic_bv</code></a></p></dd></dl><dl><dt class="spec value" id="val-(asr)"><a href="#val-(asr)" class="anchor"></a><code><span class="keyword">val</span> (asr) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><a href="index.html#val-shift_right_arith_bv"><code>shift_right_arith_bv</code></a></p></dd></dl><dl><dt class="spec value" id="val-(lnot)"><a href="#val-(lnot)" class="anchor"></a><code><span class="keyword">val</span> (lnot) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><a href="index.html#val-lognot"><code>lognot</code></a></p></dd></dl><dl><dt class="spec value" id="val-(land)"><a href="#val-(land)" class="anchor"></a><code><span class="keyword">val</span> (land) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><a href="index.html#val-logand"><code>logand</code></a></p></dd></dl><dl><dt class="spec value" id="val-(lor)"><a href="#val-(lor)" class="anchor"></a><code><span class="keyword">val</span> (lor) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><a href="index.html#val-logor"><code>logor</code></a></p></dd></dl><dl><dt class="spec value" id="val-(lxor)"><a href="#val-(lxor)" class="anchor"></a><code><span class="keyword">val</span> (lxor) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><a href="index.html#val-logxor"><code>logxor</code></a></p></dd></dl></section></div></body></html>