<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ast__Manip (read-dwarf.Ast__Manip)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">read-dwarf</a> &#x00BB; Ast__Manip</nav><h1>Module <code>Ast__Manip</code></h1><p>This module provide generic facilities of expression and SMT statements provided by <a href="../Ast/index.html"><code>Ast</code></a>. It is intended to only provide syntactic facilities over <a href="../Ast/index.html"><code>Ast</code></a> types, in particular <a href="../Ast/index.html#type-exp"><code>Ast.exp</code></a>.</p><p>In particular it provides generic mapping and iteration function over expressions as well a function allowing to convert between the various <a href="../SymbolicExpressions.html#typopt"><span>Expression type parameter and options</span></a>.</p><p>Warning: due to OCaml type system limitations, mainly <a href="https://github.com/ocaml/ocaml/issues/9459">issue <code>#9456</code></a>, this module is sometimes required to use <span class="xref-unresolved" title="unresolved reference to &quot;Obj.magic&quot;"><code>Obj</code>.magic</span> in some specific cases. No other module should ever do that. If you need to use <code>Obj.magic</code> to bypass OCaml type system limitation about <a href="../Ast/index.html"><code>Ast</code></a> type, add a function here instead.</p><nav class="toc"><ul><li><a href="#get-annotations">Get annotations</a></li><li><a href="#non-recursive-maps-and-iters">Non-recursive maps and iters</a></li><li><a href="#recursive-maps-and-iters">Recursive maps and iters</a></li><li><a href="#variable-type-conversion">Variable type conversion</a></li><li><a href="#bound-variables-and-let-bindings">Bound variables and let-bindings</a></li><li><a href="#memory-operation">Memory operation</a></li></ul></nav></header><section><header><h2 id="get-annotations"><a href="#get-annotations" class="anchor"></a>Get annotations</h2></header><dl><dt class="spec value" id="val-annot_exp"><a href="#val-annot_exp" class="anchor"></a><code><span class="keyword">val</span> annot_exp : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'v</span>, <span class="type-var">'b</span>, <span class="type-var">'m</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Get the annotation of an expression</p><p>TODO: This would be much more efficient if the annotation was always the first member of the constructor and not the last (in that case the offset to fetch the annotation do not depend on the constructor index). This may require to modify ott.</p></dd></dl></section><section><header><h2 id="non-recursive-maps-and-iters"><a href="#non-recursive-maps-and-iters" class="anchor"></a>Non-recursive maps and iters</h2><p>This section is filled on demand.</p><p><code>direct_a_map_b</code> take a function <code>b -&gt; b</code> and applies it to all <code>b</code> in <code>a</code>, non-recursively. Then a new a with the same structure is formed.</p><p><code>direct_a_iter_b</code> take a function <code>b -&gt; unit</code> and applies it to all <code>b</code> in <code>a</code>, non-recursively.</p></header><dl><dt class="spec value" id="val-direct_exp_map_exp"><a href="#val-direct_exp_map_exp" class="anchor"></a><code><span class="keyword">val</span> direct_exp_map_exp : <span>(<span><span>(<span class="type-var">'a</span>, <span class="type-var">'v</span>, <span class="type-var">'b</span>, <span class="type-var">'m</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'v</span>, <span class="type-var">'b</span>, <span class="type-var">'m</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'v</span>, <span class="type-var">'b</span>, <span class="type-var">'m</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'v</span>, <span class="type-var">'b</span>, <span class="type-var">'m</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span></code></dt><dt class="spec value" id="val-direct_exp_iter_exp"><a href="#val-direct_exp_iter_exp" class="anchor"></a><code><span class="keyword">val</span> direct_exp_iter_exp : <span>(<span><span>(<span class="type-var">'a</span>, <span class="type-var">'v</span>, <span class="type-var">'b</span>, <span class="type-var">'m</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'v</span>, <span class="type-var">'b</span>, <span class="type-var">'m</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-direct_exp_fold_left_exp"><a href="#val-direct_exp_fold_left_exp" class="anchor"></a><code><span class="keyword">val</span> direct_exp_fold_left_exp : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>, <span class="type-var">'e</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>, <span class="type-var">'e</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-direct_exp_for_all_exp"><a href="#val-direct_exp_for_all_exp" class="anchor"></a><code><span class="keyword">val</span> direct_exp_for_all_exp : <span>(<span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-direct_exp_exists_exp"><a href="#val-direct_exp_exists_exp" class="anchor"></a><code><span class="keyword">val</span> direct_exp_exists_exp : <span>(<span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span> <span>&#45;&gt;</span> bool</code></dt></dl></section><section><header><h2 id="recursive-maps-and-iters"><a href="#recursive-maps-and-iters" class="anchor"></a>Recursive maps and iters</h2><p>This section is filled on demand.</p><p><code>a_map_b</code> take a function <code>b -&gt; b</code> and applies it to all the <code>b</code> in <code>a</code>, and do that recursively on all b that appear directly or indirectly in a</p><p><code>a_iter_b</code> take a function <code>b -&gt; unit</code> and applies it to all the <code>b</code> in <code>a</code>, and do that recursively</p><p>Doing this when <code>a = b</code> is not well defined, and can be easily done using the direct version from previous section.</p></header><dl><dt class="spec value" id="val-exp_iter_var"><a href="#val-exp_iter_var" class="anchor"></a><code><span class="keyword">val</span> exp_iter_var : <span>(<span class="type-var">'v</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'v</span>, <span class="type-var">'b</span>, <span class="type-var">'m</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Iterate a function on all the variable of an expression</p></dd></dl><dl><dt class="spec value" id="val-exp_map_var"><a href="#val-exp_map_var" class="anchor"></a><code><span class="keyword">val</span> exp_map_var : <span>(<span class="type-var">'va</span> <span>&#45;&gt;</span> <span class="type-var">'vb'</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'va</span>, <span class="type-var">'b</span>, <span class="type-var">'m</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'vb'</span>, <span class="type-var">'b</span>, <span class="type-var">'m</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span></code></dt><dt class="spec value" id="val-exp_iter_annot"><a href="#val-exp_iter_annot" class="anchor"></a><code><span class="keyword">val</span> exp_iter_annot : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'v</span>, <span class="type-var">'b</span>, <span class="type-var">'m</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Iterate a function on all the annotations of an expression</p></dd></dl></section><section><header><h2 id="variable-type-conversion"><a href="#variable-type-conversion" class="anchor"></a>Variable type conversion</h2><p>All of those function convert the underlying variable type through the AST. They cannot be the usual map function because they change the type</p></header><dl><dt class="spec value" id="val-exp_conv_var"><a href="#val-exp_conv_var" class="anchor"></a><code><span class="keyword">val</span> exp_conv_var : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'c</span>, <span class="type-var">'a</span>, <span class="type-var">'d</span>, <span class="type-var">'e</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'c</span>, <span class="type-var">'b</span>, <span class="type-var">'d</span>, <span class="type-var">'e</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span></code></dt><dd><p>Old alias to make conversion explicit</p></dd></dl><dl><dt class="spec value" id="val-exp_var_subst"><a href="#val-exp_var_subst" class="anchor"></a><code><span class="keyword">val</span> exp_var_subst : <span>(<span class="type-var">'va</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'vb</span>, <span class="type-var">'b</span>, <span class="type-var">'m</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'va</span>, <span class="type-var">'b</span>, <span class="type-var">'m</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'vb</span>, <span class="type-var">'b</span>, <span class="type-var">'m</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span></code></dt><dd><p>Substitute variable with expression according to substitution function</p></dd></dl></section><section><header><h2 id="bound-variables-and-let-bindings"><a href="#bound-variables-and-let-bindings" class="anchor"></a>Bound variables and let-bindings</h2><p>This section allow to go from expression without let-bindings to expression with them and vice-versa.</p></header><dl><dt class="spec value" id="val-allow_lets"><a href="#val-allow_lets" class="anchor"></a><code><span class="keyword">val</span> allow_lets : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'v</span>, <a href="../Ast/Base/index.html#type-no">Ast.Base.no</a>, <span class="type-var">'m</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'v</span>, <span class="type-var">'b</span>, <span class="type-var">'m</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span></code></dt><dd><p>Allow bound variables and lets in an expression. This operation is a no-op and has no runtime cost, it's just a type change.</p></dd></dl><dl><dt class="spec value" id="val-smt_allow_lets"><a href="#val-smt_allow_lets" class="anchor"></a><code><span class="keyword">val</span> smt_allow_lets : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'v</span>, <a href="../Ast/Base/index.html#type-no">Ast.Base.no</a>, <span class="type-var">'m</span>)</span> <a href="../Ast/Base/index.html#type-smt">Ast.Base.smt</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'v</span>, <span class="type-var">'b</span>, <span class="type-var">'m</span>)</span> <a href="../Ast/Base/index.html#type-smt">Ast.Base.smt</a></span></code></dt><dd><p>Same as <a href="index.html#val-allow_lets"><code>allow_lets</code></a> but for the <code>smt</code> type</p></dd></dl><dl><dt class="spec value" id="val-unfold_lets"><a href="#val-unfold_lets" class="anchor"></a><code><span class="keyword">val</span> unfold_lets : <span>?&#8288;context:<span><span>(<span class="type-var">'b1</span>, <span><span>(<span class="type-var">'a</span>, <span class="type-var">'v</span>, <span class="type-var">'b2</span>, <span class="type-var">'m</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span>)</span> Stdlib.Hashtbl.t</span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'v</span>, <span class="type-var">'b1</span>, <span class="type-var">'m</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'v</span>, <span class="type-var">'b2</span>, <span class="type-var">'m</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span></code></dt><dd><p>Unfold all lets. There are no remaining lets in the output, Therefore the output type of let binding can be anything including <a href="../Ast/index.html#type-no"><code>Ast.no</code></a>. In particular doing <a href="index.html#val-allow_lets"><code>allow_lets</code></a> after this function is useless</p></dd></dl></section><section><header><h2 id="memory-operation"><a href="#memory-operation" class="anchor"></a>Memory operation</h2><p>This section allow to go from expression without memory operations to expression with them and vice-versa.</p></header><dl><dt class="spec value" id="val-allow_mem"><a href="#val-allow_mem" class="anchor"></a><code><span class="keyword">val</span> allow_mem : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'v</span>, <span class="type-var">'b</span>, <a href="../Ast/Base/index.html#type-no">Ast.Base.no</a>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'v</span>, <span class="type-var">'b</span>, <span class="type-var">'m</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span></code></dt><dd><p>Allow memory operations in an expression.</p></dd></dl><dl><dt class="spec value" id="val-smt_allow_mem"><a href="#val-smt_allow_mem" class="anchor"></a><code><span class="keyword">val</span> smt_allow_mem : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'v</span>, <span class="type-var">'b</span>, <a href="../Ast/Base/index.html#type-no">Ast.Base.no</a>)</span> <a href="../Ast/Base/index.html#type-smt">Ast.Base.smt</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'v</span>, <span class="type-var">'b</span>, <span class="type-var">'m</span>)</span> <a href="../Ast/Base/index.html#type-smt">Ast.Base.smt</a></span></code></dt><dd><p>Same as <a href="index.html#val-allow_mem"><code>allow_mem</code></a> but for the <code>smt</code> type</p></dd></dl><dl><dt class="spec value" id="val-ty_allow_mem"><a href="#val-ty_allow_mem" class="anchor"></a><code><span class="keyword">val</span> ty_allow_mem : <span><a href="../Ast/Base/index.html#type-no">Ast.Base.no</a> <a href="../Ast/Base/index.html#type-ty">Ast.Base.ty</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'m</span> <a href="../Ast/Base/index.html#type-ty">Ast.Base.ty</a></span></code></dt><dd><p>Same as <a href="index.html#val-allow_mem"><code>allow_mem</code></a> but for the <code>ty</code> type</p></dd></dl><dl><dt class="spec value" id="val-check_no_mem"><a href="#val-check_no_mem" class="anchor"></a><code><span class="keyword">val</span> check_no_mem : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'v</span>, <span class="type-var">'b</span>, <span class="type-var">'m</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Check that not memory operation take place in that expression. Return <code>true</code> if that's the case and <code>false</code> otherwise.</p><p>This is not resilient to change of type: If a new memory constructor is added, then this function will be wrong</p></dd></dl><dl><dt class="spec value" id="val-expect_no_mem"><a href="#val-expect_no_mem" class="anchor"></a><code><span class="keyword">val</span> expect_no_mem : <span>?&#8288;handler:<span>(unit <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'v</span>, <span class="type-var">'b</span>, <span class="type-var">'m2</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span>)</span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'v</span>, <span class="type-var">'b</span>, <span class="type-var">'m1</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'v</span>, <span class="type-var">'b</span>, <span class="type-var">'m2</span>)</span> <a href="../Ast/Base/index.html#type-exp">Ast.Base.exp</a></span></code></dt><dd><p>Expect that an <code>exp</code> has no memory constructor, and then return it with memory removed from the type. Throws <code>Failure</code> if the value had memory constructors.</p><p>This is not resilient to change of type, If a new memory constructor is added, then this function will be unsound.</p><p>TODO: Find a way to make it resilient</p></dd></dl></section></div></body></html>