<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Reg (read-dwarf.State.Reg)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">read-dwarf</a> &#x00BB; <a href="../index.html">State</a> &#x00BB; Reg</nav><h1>Module <code>State.Reg</code></h1><p>This module handle the register abstraction.</p><p>A register is defined by a <a href="Path/index.html"><code>Path</code></a> and a type <a href="index.html#type-ty"><code>ty</code></a>. The path is a representation of dot separated list of identifiers.</p><p>Registers are not part of the <a href="../../Arch/index.html"><code>Arch</code></a> module because they are discovered dynamically. This module keeps a global index of all register of the current architecture (in a <a href="../../Utils/IdMap/index.html"><code>IdMap</code></a>). This map also fix the types of registers.</p><p>This allow to represent registers as integer everywhere.</p><p>The module also provides <a href="Map/index.html"><code>Map</code></a> and <code>PMap</code> a respectively full and partial maps over registers. They need special support (especially the full map) because new registers may be added at any time after the creation of the map.</p><p>TODO: Support sail vectors (A path will be of type (string + int) list)</p><nav class="toc"><ul><li><a href="#paths">Paths</a></li><li><a href="#registers">Registers</a></li><li><a href="#register-map">Register map</a></li></ul></nav></header><section><header><h2 id="paths"><a href="#paths" class="anchor"></a>Paths</h2><p>Representation of register path. The string reprensentation is with dots. A name may not contain dots, but this is not checked.</p></header><div class="spec module" id="module-Path"><a href="#module-Path" class="anchor"></a><code><span class="keyword">module</span> <a href="Path/index.html">Path</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h2 id="registers"><a href="#registers" class="anchor"></a>Registers</h2><p>Global register properties and accessors</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = <span class="keyword">private</span> int</code></dt><dd><p>The type representing a register. The module invariant is that this type always contains a value bound in the global index and so this is always a valid register id.</p></dd></dl><dl><dt class="spec type" id="type-ty"><a href="#type-ty" class="anchor"></a><code><span class="keyword">type</span> ty</code><code> = <span><a href="../../Ast/index.html#type-no">Ast.no</a> <a href="../../Ast/index.html#type-ty">Ast.ty</a></span></code></dt><dd><p>The type of a register. This is isomorphic to <span class="xref-unresolved" title="unresolved reference to &quot;Isla.ty&quot;"><a href="../../Isla/index.html"><code>Isla</code></a>.ty</span>. Use <span class="xref-unresolved" title="unresolved reference to &quot;IslaConv.ty&quot;"><code>IslaConv</code>.ty</span> to convert</p></dd></dl><dl><dt class="spec value" id="val-of_int"><a href="#val-of_int" class="anchor"></a><code><span class="keyword">val</span> of_int : int <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> option</span></code></dt><dd><p>Convert an integer into the corresponding register.</p></dd></dl><dl><dt class="spec value" id="val-mem_path"><a href="#val-mem_path" class="anchor"></a><code><span class="keyword">val</span> mem_path : <a href="Path/index.html#type-t">Path.t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Check if register is declared with that path</p></dd></dl><dl><dt class="spec value" id="val-mem_string"><a href="#val-mem_string" class="anchor"></a><code><span class="keyword">val</span> mem_string : string <span>&#45;&gt;</span> bool</code></dt><dd><p>Check if a register is declared with that name. Same as <code>Path.of_string |&gt; mem_path</code></p></dd></dl><dl><dt class="spec value" id="val-of_path"><a href="#val-of_path" class="anchor"></a><code><span class="keyword">val</span> of_path : <a href="Path/index.html#type-t">Path.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Give the register corresponding to that path</p></dd></dl><dl><dt class="spec value" id="val-to_path"><a href="#val-to_path" class="anchor"></a><code><span class="keyword">val</span> to_path : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Path/index.html#type-t">Path.t</a></code></dt><dd><p>Give the path of a register</p></dd></dl><dl><dt class="spec value" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span class="keyword">val</span> of_string : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Give the register corresponding to a register name</p></dd></dl><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Give the name of a register</p></dd></dl><dl><dt class="spec value" id="val-num"><a href="#val-num" class="anchor"></a><code><span class="keyword">val</span> num : unit <span>&#45;&gt;</span> int</code></dt><dd><p>Give the current number of registers</p></dd></dl><dl><dt class="spec value" id="val-reg_type"><a href="#val-reg_type" class="anchor"></a><code><span class="keyword">val</span> reg_type : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-ty">ty</a></code></dt><dd><p>Give the type of a register</p></dd></dl><dl><dt class="spec value" id="val-path_type"><a href="#val-path_type" class="anchor"></a><code><span class="keyword">val</span> path_type : <a href="Path/index.html#type-t">Path.t</a> <span>&#45;&gt;</span> <a href="index.html#type-ty">ty</a></code></dt><dd><p>Give the type of register path. Throw <code>Not_found</code>, it that path is not a declared register</p></dd></dl><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val</span> add : <a href="Path/index.html#type-t">Path.t</a> <span>&#45;&gt;</span> <a href="index.html#type-ty">ty</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Add a new register to the global <a href="../../index.html"><code>index</code></a>. Return it's representation</p></dd></dl><dl><dt class="spec value" id="val-ensure_add"><a href="#val-ensure_add" class="anchor"></a><code><span class="keyword">val</span> ensure_add : <a href="Path/index.html#type-t">Path.t</a> <span>&#45;&gt;</span> <a href="index.html#type-ty">ty</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Ensure that a register with that path exists with that type, by adding it or checking it already exists with that type. Return the corresponding register</p></dd></dl><dl><dt class="spec value" id="val-adds"><a href="#val-adds" class="anchor"></a><code><span class="keyword">val</span> adds : <a href="Path/index.html#type-t">Path.t</a> <span>&#45;&gt;</span> <a href="index.html#type-ty">ty</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Same as <a href="index.html#val-add"><code>add</code></a> but returns unit</p></dd></dl><dl><dt class="spec value" id="val-ensure_adds"><a href="#val-ensure_adds" class="anchor"></a><code><span class="keyword">val</span> ensure_adds : <a href="Path/index.html#type-t">Path.t</a> <span>&#45;&gt;</span> <a href="index.html#type-ty">ty</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Ensure that a register with that path exists with that type, by adding it or checking it already exists with that type.</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span>(<a href="Path/index.html#type-t">Path.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-ty">ty</a> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Run a function over all registers</p></dd></dl><dl><dt class="spec value" id="val-seq_all"><a href="#val-seq_all" class="anchor"></a><code><span class="keyword">val</span> seq_all : unit <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="../../Utils/index.html#module-Seq">Utils.Seq</a>.t</span></code></dt><dd><p>Returns a sequence of all registers</p></dd></dl><dl><dt class="spec value" id="val-(=)"><a href="#val-(=)" class="anchor"></a><code><span class="keyword">val</span> (=) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Equality predicate</p></dd></dl><dl><dt class="spec value" id="val-(&lt;&gt;)"><a href="#val-(&lt;&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;&gt;) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Inequality predicate</p></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Compare according to an implementation-defined total order.</p></dd></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../Utils/index.html#module-Pp">Utils.Pp</a>.document</code></dt><dd><p>Pretty prints a register (Just use <a href="index.html#val-to_string"><code>to_string</code></a>)</p></dd></dl><dl><dt class="spec value" id="val-pp_ty"><a href="#val-pp_ty" class="anchor"></a><code><span class="keyword">val</span> pp_ty : <a href="index.html#type-ty">ty</a> <span>&#45;&gt;</span> <a href="../../Utils/index.html#module-Pp">Utils.Pp</a>.document</code></dt><dd><p>Pretty prints a register type</p></dd></dl><dl><dt class="spec value" id="val-pp_index"><a href="#val-pp_index" class="anchor"></a><code><span class="keyword">val</span> pp_index : unit <span>&#45;&gt;</span> <a href="../../Utils/index.html#module-Pp">Utils.Pp</a>.document</code></dt><dd><p>Prints the register index (mainly for debugging I suppose)</p></dd></dl></section><section><header><h2 id="register-map"><a href="#register-map" class="anchor"></a>Register map</h2><p>To achieve a partial map on register, one may just used a plain <code>Hashtbl</code>. However as register is a finite type one may want to have a map where all the register are bound and thus access to a bound value cannot fail. This is complicated by the fact that new registers can be added after the creation of the map. To handle all those subtleties, there is the <span class="xref-unresolved" title="unresolved reference to &quot;Utils.Map&quot;"><a href="../../Utils/index.html"><code>Utils</code></a>.Map</span> module.</p></header><dl><dt class="spec module" id="module-Map"><a href="#module-Map" class="anchor"></a><code><span class="keyword">module</span> <a href="Map/index.html">Map</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>This module provide a full map over register in the same way than <a href="../../Utils/FullVec/index.html"><code>FullVec</code></a> provide a map of integers. It still need a generator to generate the value bound to not-yet-added registers.</p></dd></dl></section></div></body></html>