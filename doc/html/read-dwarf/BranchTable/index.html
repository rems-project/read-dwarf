<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>BranchTable (read-dwarf.BranchTable)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">read-dwarf</a> &#x00BB; BranchTable</nav><h1>Module <code>BranchTable</code></h1><p>This module is designed to symbolically evaluate all the branch tables in an ELF file. Known bugs:</p><ul><li>How to handle the following for live = <code>x9</code> ? 40812c: 2a0803e9 mov w9, w8 408130: 2a0903e8 mov w8, w9 408134: 71000d08 subs w8, w8, #0x3</li><li>Multiple starts</li></ul></header><div class="spec module" id="module-Analyses"><a href="#module-Analyses" class="anchor"></a><code><span class="keyword">module</span> Analyses = <a href="../BranchTable__/index.html#module-InstrsAnalyses">BranchTable__.InstrsAnalyses</a></code></div><div class="spec module" id="module-Reg"><a href="#module-Reg" class="anchor"></a><code><span class="keyword">module</span> Reg = <a href="../State/index.html#module-Reg">State.Reg</a></code></div><div class="spec module" id="module-Instr"><a href="#module-Instr" class="anchor"></a><code><span class="keyword">module</span> Instr = <a href="../Trace/index.html#module-Instr">Trace.Instr</a></code></div><div class="spec module" id="module-Runner"><a href="#module-Runner" class="anchor"></a><code><span class="keyword">module</span> Runner = <a href="../Run/index.html#module-Runner">Run.Runner</a></code></div><div class="spec module" id="module-Block"><a href="#module-Block" class="anchor"></a><code><span class="keyword">module</span> Block = <a href="../Run/index.html#module-Block_lib">Run.Block_lib</a></code></div><div class="spec module" id="module-ConcreteEval"><a href="#module-ConcreteEval" class="anchor"></a><code><span class="keyword">module</span> ConcreteEval = <a href="../Exp/index.html#module-ConcreteEval">Exp.ConcreteEval</a></code></div><div class="spec module" id="module-Value"><a href="#module-Value" class="anchor"></a><code><span class="keyword">module</span> Value = <a href="../Exp/index.html#module-Value">Exp.Value</a></code></div><dl><dt class="spec value" id="val-pp_regs"><a href="#val-pp_regs" class="anchor"></a><code><span class="keyword">val</span> pp_regs : <span><a href="../State/Reg/index.html#type-t">Reg.t</a> list</span> <span>&#45;&gt;</span> Stdlib.out_channel <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-pp_ptrs"><a href="#val-pp_ptrs" class="anchor"></a><code><span class="keyword">val</span> pp_ptrs : <span>int list</span> <span>&#45;&gt;</span> Stdlib.out_channel <span>&#45;&gt;</span> unit</code></dt></dl><dl><dt class="spec type" id="type-and_t"><a href="#type-and_t" class="anchor"></a><code><span class="keyword">type</span> and_t</code><code> = </code><table class="variant"><tr id="type-and_t.AndS" class="anchored"><td class="def constructor"><a href="#type-and_t.AndS" class="anchor"></a><code>| </code><code><span class="constructor">AndS</span> <span class="keyword">of</span> <a href="../State/Reg/index.html#type-t">Reg.t</a> * <a href="../Utils/BitVec/index.html#type-t">Utils.BitVec.t</a></code></td></tr><tr id="type-and_t.Mask" class="anchored"><td class="def constructor"><a href="#type-and_t.Mask" class="anchor"></a><code>| </code><code><span class="constructor">Mask</span> <span class="keyword">of</span> <a href="../State/Reg/index.html#type-t">Reg.t</a> * <a href="../State/Reg/index.html#type-t">Reg.t</a> * <a href="../Utils/BitVec/index.html#type-t">Utils.BitVec.t</a></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-looks_like_ands"><a href="#val-looks_like_ands" class="anchor"></a><code><span class="keyword">val</span> looks_like_ands : <a href="../Trace/Instr/index.html#type-trace_meta">Instr.trace_meta</a> <span>&#45;&gt;</span> <a href="../Trace/Instr/index.html#type-trace_meta">Instr.trace_meta</a> <span>&#45;&gt;</span> <span><a href="index.html#type-and_t">and_t</a> option</span></code></dt><dt class="spec value" id="val-looks_like_and_low_mask"><a href="#val-looks_like_and_low_mask" class="anchor"></a><code><span class="keyword">val</span> looks_like_and_low_mask : <a href="../State/Reg/index.html#type-t">Reg.t</a> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <a href="../Trace__Base/Var/index.html#type-t">Trace.Var.t</a>, <span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <a href="../Ast/index.html#type-exp">Ast.exp</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-and_t">and_t</a> option</span></code></dt><dt class="spec value" id="val-looks_like_and"><a href="#val-looks_like_and" class="anchor"></a><code><span class="keyword">val</span> looks_like_and : <span><a href="../Trace/Instr/index.html#type-trace_meta">Instr.trace_meta</a> list</span> <span>&#45;&gt;</span> <span><a href="index.html#type-and_t">and_t</a> option</span></code></dt><dt class="spec value" id="val-looks_like_csel"><a href="#val-looks_like_csel" class="anchor"></a><code><span class="keyword">val</span> looks_like_csel : <span><a href="../Trace/Instr/index.html#type-trace_meta">Instr.trace_meta</a> list</span> <span>&#45;&gt;</span> bool</code></dt></dl><dl><dt class="spec type" id="type-cmp_case"><a href="#type-cmp_case" class="anchor"></a><code><span class="keyword">type</span> cmp_case</code><code> = </code><table class="variant"><tr id="type-cmp_case.RangeFrom0" class="anchored"><td class="def constructor"><a href="#type-cmp_case.RangeFrom0" class="anchor"></a><code>| </code><code><span class="constructor">RangeFrom0</span></code></td></tr><tr id="type-cmp_case.Eq_Neq" class="anchored"><td class="def constructor"><a href="#type-cmp_case.Eq_Neq" class="anchor"></a><code>| </code><code><span class="constructor">Eq_Neq</span></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-fixup_written_read"><a href="#val-fixup_written_read" class="anchor"></a><code><span class="keyword">val</span> fixup_written_read : <span>(int <span>&#45;&gt;</span> <span><a href="../Run/Runner/index.html#type-slot">Runner.slot</a> option</span>)</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../Trace/Instr/index.html#type-t">Instr.t</a> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-cmp_case">cmp_case</a> * <span>(<a href="../State/Reg/index.html#type-t">State.Reg.t</a> * <a href="../Utils/BitVec/index.html#type-t">Utils.BitVec.t</a>)</span>)</span> option</span> * <span><a href="../State/Reg/index.html#type-t">Instr.Reg.t</a> list</span> * <span><a href="../State/Reg/index.html#type-t">State.Reg.t</a> list</span></code></dt><dd><p>Two things are 'fixed' for the reads and writes:</p><ul><li>Reads of the PC and SP are removed since they are always live</li><li>Comparisons of a register with a constant are considered a write, because we set the value of the register with a range of constants before simulating.</li></ul></dd></dl><dl><dt class="spec type" id="type-dataflow_context"><a href="#type-dataflow_context" class="anchor"></a><code><span class="keyword">type</span> dataflow_context</code><code> = </code><code>{</code><table class="record"><tr id="type-dataflow_context.instr_at" class="anchored"><td class="def field"><a href="#type-dataflow_context.instr_at" class="anchor"></a><code>instr_at : int <span>&#45;&gt;</span> <span><a href="../Run/Runner/index.html#type-slot">Runner.slot</a> option</span>;</code></td></tr><tr id="type-dataflow_context.comes_before" class="anchored"><td class="def field"><a href="#type-dataflow_context.comes_before" class="anchor"></a><code>comes_before : int <span>&#45;&gt;</span> <span><span>(int * <span>int list</span>)</span> option</span>;</code></td></tr><tr id="type-dataflow_context.spills_for" class="anchored"><td class="def field"><a href="#type-dataflow_context.spills_for" class="anchor"></a><code>spills_for : int <span>&#45;&gt;</span> <span>int list</span>;</code></td></tr><tr id="type-dataflow_context.depth_limit" class="anchored"><td class="def field"><a href="#type-dataflow_context.depth_limit" class="anchor"></a><code>depth_limit : int;</code></td></tr><tr id="type-dataflow_context.relevant_instrs" class="anchored"><td class="def field"><a href="#type-dataflow_context.relevant_instrs" class="anchor"></a><code>relevant_instrs : <span><span>(int, unit)</span> Stdlib.Hashtbl.t</span>;</code></td></tr><tr id="type-dataflow_context.relevant_spills" class="anchored"><td class="def field"><a href="#type-dataflow_context.relevant_spills" class="anchor"></a><code>relevant_spills : <span><span>(int, bool)</span> Stdlib.Hashtbl.t</span>;</code></td></tr><tr id="type-dataflow_context.live" class="anchored"><td class="def field"><a href="#type-dataflow_context.live" class="anchor"></a><code>live : <span><a href="../State/Reg/index.html#type-t">Reg.t</a> list</span>;</code></td></tr><tr id="type-dataflow_context.cmp_operands" class="anchored"><td class="def field"><a href="#type-dataflow_context.cmp_operands" class="anchor"></a><code>cmp_operands : <span><span>(<a href="index.html#type-cmp_case">cmp_case</a> * <span>(<a href="../State/Reg/index.html#type-t">Reg.t</a> * <a href="../Utils/BitVec/index.html#type-t">Utils.BitVec.t</a>)</span>)</span> option</span>;</code></td></tr></table><code>}</code></dt></dl><dl><dt class="spec exception" id="exception-DeadEnd"><a href="#exception-DeadEnd" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">DeadEnd</span></code></dt><dt class="spec exception" id="exception-MultipleStarts"><a href="#exception-MultipleStarts" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">MultipleStarts</span></code></dt><dt class="spec exception" id="exception-IrrelevantEarlyRange"><a href="#exception-IrrelevantEarlyRange" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">IrrelevantEarlyRange</span> <span class="keyword">of</span> <a href="index.html#type-cmp_case">cmp_case</a></code></dt></dl><dl><dt class="spec value" id="val-update_live"><a href="#val-update_live" class="anchor"></a><code><span class="keyword">val</span> update_live : <a href="index.html#type-dataflow_context">dataflow_context</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int * <span><span>(int, unit)</span> Stdlib.Hashtbl.t</span> * <span><span>(<a href="index.html#type-cmp_case">cmp_case</a> * <span>(<a href="../State/Reg/index.html#type-t">Reg.t</a> * <a href="../Utils/BitVec/index.html#type-t">Utils.BitVec.t</a>)</span>)</span> option</span></code></dt><dd><p>A standard backwards-dataflow analysis with following modifications:</p><ul><li>comparisons with constants are treated as writes</li><li>irrelevant instructions (those which do not write to any live registers) are ignored</li><li>relevant instructions are tracked and returned</li><li>the operands of the first relevant comparison with a constant (which is followed by a conditional branch) are also returned, if it exists</li></ul></dd></dl><dl><dt class="spec value" id="val-step_backwards"><a href="#val-step_backwards" class="anchor"></a><code><span class="keyword">val</span> step_backwards : <a href="index.html#type-dataflow_context">dataflow_context</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int * <span><span>(int, unit)</span> Stdlib.Hashtbl.t</span> * <span><span>(<a href="index.html#type-cmp_case">cmp_case</a> * <span>(<a href="../State/Reg/index.html#type-t">Reg.t</a> * <a href="../Utils/BitVec/index.html#type-t">Utils.BitVec.t</a>)</span>)</span> option</span></code></dt><dt class="spec value" id="val-reverse_dataflow"><a href="#val-reverse_dataflow" class="anchor"></a><code><span class="keyword">val</span> reverse_dataflow : <span><span>(int, <a href="../Run/Runner/index.html#type-slot">Runner.slot</a>)</span> Stdlib.Hashtbl.t</span> <span>&#45;&gt;</span> <span><span>(int, int * <span>int list</span>)</span> Stdlib.Hashtbl.t</span> <span>&#45;&gt;</span> <span><span><span>(int, int)</span> Stdlib.Hashtbl.t</span> Stdlib.Lazy.t</span> <span>&#45;&gt;</span> <a href="../BranchTable__/InstrsAnalyses/index.html#type-reg_branches">Analyses.reg_branches</a> <span>&#45;&gt;</span> <span><span>(int * <span>(int * <span><span>(int, unit)</span> Stdlib.Hashtbl.t</span> * <span><span>(<a href="index.html#type-cmp_case">cmp_case</a> * <span>(<a href="../State/Reg/index.html#type-t">Reg.t</a> * <a href="../Utils/BitVec/index.html#type-t">Utils.BitVec.t</a>)</span>)</span> option</span>)</span>)</span> list</span></code></dt><dd><p>Work backwards through the dataflow of the registers to find the earliest instruction from which point to run a straight-line simluation.</p><p>This function returns a tuple containing:</p><ul><li>the address of the start of the branch-register target computation</li><li>the set of instruction addresses which are relevant between the start (inclusive) and the branch-register instruction (exclusive)</li><li>the register that must be set with a value before simulating the relevant instructions</li><li>the inclusive maximum value which that register should be set to</li></ul></dd></dl><dl><dt class="spec value" id="val-make_block"><a href="#val-make_block" class="anchor"></a><code><span class="keyword">val</span> make_block : <a href="../Run/Runner/index.html#type-t">Run.Runner.t</a> <span>&#45;&gt;</span> <span>(int * <span>(int * <span><span>(int, unit)</span> Stdlib.Hashtbl.t</span> * <span class="type-var">'a</span>)</span>)</span> <span>&#45;&gt;</span> int * <span>(<span>(unit <span>&#45;&gt;</span> <a href="../Run/Block_lib/index.html#type-t">Block.t</a>)</span> * <span><span>(int, unit)</span> Stdlib.Hashtbl.t</span> * <span class="type-var">'a</span>)</span></code></dt></dl><dl><dt class="spec type" id="type-pc_exp_guess"><a href="#type-pc_exp_guess" class="anchor"></a><code><span class="keyword">type</span> pc_exp_guess</code><code> = </code><table class="variant"><tr id="type-pc_exp_guess.Sym" class="anchored"><td class="def constructor"><a href="#type-pc_exp_guess.Sym" class="anchor"></a><code>| </code><code><span class="constructor">Sym</span> <span class="keyword">of</span> <span><a href="../Run/Block_lib/index.html#type-label">Block.label</a> <a href="../State/Tree/index.html#type-t">State.Tree.t</a></span></code></td></tr><tr id="type-pc_exp_guess.Ints" class="anchored"><td class="def constructor"><a href="#type-pc_exp_guess.Ints" class="anchor"></a><code>| </code><code><span class="constructor">Ints</span> <span class="keyword">of</span> <span><span><a href="../Run/Block_lib/index.html#type-label">Block.label</a> <a href="../State/Tree/index.html#type-t">State.Tree.t</a></span> array</span></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-symeval_range_for_trees"><a href="#val-symeval_range_for_trees" class="anchor"></a><code><span class="keyword">val</span> symeval_range_for_trees : <a href="../Elf/File/index.html#type-t">Elf.File.t</a> <span>&#45;&gt;</span> <a href="../State/index.html#type-t">State.t</a> <span>&#45;&gt;</span> <span>(<span>(unit <span>&#45;&gt;</span> <a href="../Run/Block_lib/index.html#type-t">Block.t</a>)</span> * <span><span>(int, <span class="type-var">'a</span>)</span> Stdlib.Hashtbl.t</span> * <span><span>(<a href="index.html#type-cmp_case">cmp_case</a> * <span>(<a href="../State/Reg/index.html#type-t">State.Reg.t</a> * <a href="../Utils/BitVec/index.html#type-t">Utils.BitVec.t</a>)</span>)</span> option</span>)</span> <span>&#45;&gt;</span> <a href="index.html#type-pc_exp_guess">pc_exp_guess</a></code></dt></dl><dl><dt class="spec type" id="type-target"><a href="#type-target" class="anchor"></a><code><span class="keyword">type</span> <span>'a target</span></code><code> = </code><table class="variant"><tr id="type-target.Sym" class="anchored"><td class="def constructor"><a href="#type-target.Sym" class="anchor"></a><code>| </code><code><span class="constructor">Sym</span> <span class="keyword">of</span> <a href="../State/index.html#type-exp">State.exp</a> * <span><span>(<a href="../State/index.html#type-var">State.var</a> * <a href="../State/index.html#type-exp">State.exp</a>)</span> list</span></code></td></tr><tr id="type-target.Conc" class="anchored"><td class="def constructor"><a href="#type-target.Conc" class="anchor"></a><code>| </code><code><span class="constructor">Conc</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> list</span></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-map_target"><a href="#val-map_target" class="anchor"></a><code><span class="keyword">val</span> map_target : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-target">target</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-target">target</a></span></code></dt><dt class="spec value" id="val-exp_to_int"><a href="#val-exp_to_int" class="anchor"></a><code><span class="keyword">val</span> exp_to_int : <span>?&#8288;ctxt:<span><span class="type-var">'a</span> <a href="../Exp/ConcreteEval/index.html#type-context">ConcreteEval.context</a></span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'a</span>, <a href="../Ast/index.html#type-no">Ast.no</a>, <a href="../Ast/index.html#type-no">Ast.no</a>)</span> <a href="../Ast/index.html#type-exp">Ast.exp</a></span> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-target_to_ints"><a href="#val-target_to_ints" class="anchor"></a><code><span class="keyword">val</span> target_to_ints : <span>int <a href="index.html#type-target">target</a></span> <span>&#45;&gt;</span> <span>int list</span></code></dt><dt class="spec value" id="val-int_or_sym"><a href="#val-int_or_sym" class="anchor"></a><code><span class="keyword">val</span> int_or_sym : <span>(<a href="../State/index.html#type-t">State.t</a> * <span><span>(<span><a href="../Ast/index.html#type-no">Ast.no</a> <a href="../Ast/index.html#type-ty">Ast.ty</a></span>, <a href="../State__Base/Exp/index.html#type-var">State.Exp.var</a>, <a href="../Ast/index.html#type-no">Ast.no</a>, <a href="../Ast/index.html#type-no">Ast.no</a>)</span> <a href="../Ast/index.html#type-exp">Ast.exp</a></span>)</span> <span>&#45;&gt;</span> <span>int <a href="index.html#type-target">target</a></span></code></dt><dt class="spec value" id="val-pp_target"><a href="#val-pp_target" class="anchor"></a><code><span class="keyword">val</span> pp_target : <span>int <a href="index.html#type-target">target</a></span> <span>&#45;&gt;</span> PPrintEngine.document</code></dt><dt class="spec value" id="val-extract_branch_targets"><a href="#val-extract_branch_targets" class="anchor"></a><code><span class="keyword">val</span> extract_branch_targets : <a href="../State/Reg/index.html#type-t">State.Reg.t</a> <span>&#45;&gt;</span> <a href="index.html#type-pc_exp_guess">pc_exp_guess</a> <span>&#45;&gt;</span> <span>int <a href="index.html#type-target">target</a></span></code></dt><dt class="spec value" id="val-process_sym"><a href="#val-process_sym" class="anchor"></a><code><span class="keyword">val</span> process_sym : <span><a href="../Utils/index.html#module-String">Utils.String</a>.t <a href="../Utils/index.html#module-List">Utils.List</a>.t</span> <span>&#45;&gt;</span> <a href="../Dw/index.html#type-t">Dw.t</a> <span>&#45;&gt;</span> <a href="../State/index.html#type-t">State.t</a> <span>&#45;&gt;</span> <span><span>(int * string * <span>int <a href="index.html#type-target">target</a></span>)</span> list</span></code></dt><dt class="spec value" id="val-get_branches"><a href="#val-get_branches" class="anchor"></a><code><span class="keyword">val</span> get_branches : bool <span>&#45;&gt;</span> <span><a href="../Utils/index.html#module-String">Utils.String</a>.t <a href="../Utils/index.html#module-List">Utils.List</a>.t</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span>(int * string * <span>int <a href="index.html#type-target">target</a></span>)</span> list</span></code></dt><dt class="spec value" id="val-symeval_branch_table"><a href="#val-symeval_branch_table" class="anchor"></a><code><span class="keyword">val</span> symeval_branch_table : string <span>&#45;&gt;</span> <span><a href="../Utils/index.html#module-String">Utils.String</a>.t <a href="../Utils/index.html#module-List">Utils.List</a>.t</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-elf"><a href="#val-elf" class="anchor"></a><code><span class="keyword">val</span> elf : <span>string Cmdliner.Term.t</span></code></dt><dt class="spec value" id="val-funcs"><a href="#val-funcs" class="anchor"></a><code><span class="keyword">val</span> funcs : <span><span>string list</span> Cmdliner.Term.t</span></code></dt><dt class="spec value" id="val-term"><a href="#val-term" class="anchor"></a><code><span class="keyword">val</span> term : <span>unit Cmdliner.Term.t</span></code></dt><dt class="spec value" id="val-info"><a href="#val-info" class="anchor"></a><code><span class="keyword">val</span> info : Cmdliner.Term.info</code></dt><dt class="spec value" id="val-command"><a href="#val-command" class="anchor"></a><code><span class="keyword">val</span> command : <span>unit Cmdliner.Term.t</span> * Cmdliner.Term.info</code></dt></dl></div></body></html>