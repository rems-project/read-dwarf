<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Run__Runner (read-dwarf.Run__Runner)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">read-dwarf</a> &#x00BB; Run__Runner</nav><h1>Module <code>Run__Runner</code></h1><p>This module provide the program runner that caches all the information required to make a state transition</p><p>Later this module will handle inlining in a transparent way, and may also compress basic block traces (We'll need to check this is okay with type inference)</p><p>For now this module load instructions on a per-symbol basis, and do not try to load instructions outside of function symbol. TODO: remove this restriction.</p><p>The final goal of this module is to encode all necessary information to perform a state transition. In particular, the <a href="index.html#val-run"><code>run</code></a> function should never require more argument: If extra information is required, it should be part of the runner if it is dependent on the whole program or in the state if it is specific to the state.</p></header><div class="spec module" id="module-Reg"><a href="#module-Reg" class="anchor"></a><code><span class="keyword">module</span> Reg = <a href="../State/index.html#module-Reg">State.Reg</a></code></div><dl><dt class="spec type" id="type-slot"><a href="#type-slot" class="anchor"></a><code><span class="keyword">type</span> slot</code><code> = </code><table class="variant"><tr id="type-slot.Normal" class="anchored"><td class="def constructor"><a href="#type-slot.Normal" class="anchor"></a><code>| </code><code><span class="constructor">Normal</span> <span class="keyword">of</span> <a href="../Trace/Instr/index.html#type-t">Trace.Instr.t</a></code></td><td class="doc"><p>The traces and the size of the instruction</p></td></tr><tr id="type-slot.Special" class="anchored"><td class="def constructor"><a href="#type-slot.Special" class="anchor"></a><code>| </code><code><span class="constructor">Special</span> <span class="keyword">of</span> int</code></td><td class="doc"><p>Special instructions. Will be used to represent external events</p></td></tr><tr id="type-slot.Nocode" class="anchored"><td class="def constructor"><a href="#type-slot.Nocode" class="anchor"></a><code>| </code><code><span class="constructor">Nocode</span></code></td><td class="doc"><p>The is no code at this address. Running it is UB. Also used if an address is in between instructions</p></td></tr><tr id="type-slot.IslaFail" class="anchored"><td class="def constructor"><a href="#type-slot.IslaFail" class="anchor"></a><code>| </code><code><span class="constructor">IslaFail</span> <span class="keyword">of</span> int</code></td><td class="doc"><p>This means Isla pipeline failed on that instruction</p></td></tr></table></dt><dd><p>Give the instruction descriptor at a given address</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = </code><code>{</code><table class="record"><tr id="type-t.elf" class="anchored"><td class="def field"><a href="#type-t.elf" class="anchor"></a><code>elf : <a href="../Elf/File/index.html#type-t">Elf.File.t</a>;</code></td></tr><tr id="type-t.dwarf" class="anchored"><td class="def field"><a href="#type-t.dwarf" class="anchor"></a><code>dwarf : <span><a href="../Dw/index.html#type-t">Dw.t</a> option</span>;</code></td></tr><tr id="type-t.instrs" class="anchored"><td class="def field"><a href="#type-t.instrs" class="anchor"></a><code>instrs : <span><span>(int, <a href="index.html#type-slot">slot</a>)</span> Stdlib.Hashtbl.t</span>;</code></td><td class="doc"><p>Instruction cache</p></td></tr><tr id="type-t.pc" class="anchored"><td class="def field"><a href="#type-t.pc" class="anchor"></a><code>pc : <a href="../State/Reg/index.html#type-t">Reg.t</a>;</code></td></tr><tr id="type-t.funcs" class="anchored"><td class="def field"><a href="#type-t.funcs" class="anchor"></a><code>funcs : <span>int <a href="../Utils/Vec/index.html#type-t">Utils.Vec.t</a></span>;</code></td><td class="doc"><p>Loaded functions by loading order</p></td></tr></table><code>}</code></dt></dl><dl><dt class="spec value" id="val-of_elf"><a href="#val-of_elf" class="anchor"></a><code><span class="keyword">val</span> of_elf : <span>?&#8288;dwarf:<a href="../Dw/index.html#type-t">Dw.t</a></span> <span>&#45;&gt;</span> <a href="../Elf/File/index.html#type-t">Elf.File.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-of_dwarf"><a href="#val-of_dwarf" class="anchor"></a><code><span class="keyword">val</span> of_dwarf : <a href="../Dw/index.html#type-t">Dw.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-load_sym"><a href="#val-load_sym" class="anchor"></a><code><span class="keyword">val</span> load_sym : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Elf/Symbol/index.html#type-t">Elf.Symbol.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Load a symbol into the runner. All instruction traces are fetched and cached.</p><p>TODO support variable length instructions.</p></dd></dl><dl><dt class="spec value" id="val-fetch"><a href="#val-fetch" class="anchor"></a><code><span class="keyword">val</span> fetch : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-slot">slot</a></code></dt><dd><p>Fetch an instruction, and return corresponding slot.</p></dd></dl><dl><dt class="spec value" id="val-execute_normal"><a href="#val-execute_normal" class="anchor"></a><code><span class="keyword">val</span> execute_normal : <span>?&#8288;prelock:<span>(<a href="../State/index.html#type-t">State.t</a> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>pc:int</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Trace/Instr/index.html#type-t">Trace.Instr.t</a> <span>&#45;&gt;</span> <a href="../State/index.html#type-t">State.t</a> <span>&#45;&gt;</span> <span><a href="../State/index.html#type-t">State.t</a> list</span></code></dt><dd><p>Run the traces on the state.</p><p>If the state is unlocked and the instruction is single trace, then the function mutates the state and returns the same state.</p><p>Otherwise the state is locked (if not) and new states are returned</p><p>In any case the returned states are unlocked.</p></dd></dl><dl><dt class="spec value" id="val-skip"><a href="#val-skip" class="anchor"></a><code><span class="keyword">val</span> skip : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../State/index.html#type-t">State.t</a> <span>&#45;&gt;</span> <span><a href="../State/index.html#type-t">State.t</a> list</span></code></dt><dt class="spec value" id="val-run"><a href="#val-run" class="anchor"></a><code><span class="keyword">val</span> run : <span>?&#8288;prelock:<span>(<a href="../State/index.html#type-t">State.t</a> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../State/index.html#type-t">State.t</a> <span>&#45;&gt;</span> <span><a href="../State/index.html#type-t">State.t</a> list</span></code></dt><dd><p>Do the whole fetch and execute cycle. Take the PC from the state, and fetch it's <span class="xref-unresolved" title="unresolved reference to &quot;Instr&quot;"><span>instruction</span></span> and then run it. It return the list of possible behavior of that instruction. Normally the union of the set of concrete states represented by this list of symbolic state cover all the defined behaviors of the fetched instruction from the initial state.</p><p>If the state is unlocked and the instruction is single trace, then the function mutates the state and returns the same state.</p><p>Otherwise the state is locked (if not) and new unlocked states are returned.</p><p>In any case the returned states are unlocked.</p></dd></dl><dl><dt class="spec value" id="val-expect_normal"><a href="#val-expect_normal" class="anchor"></a><code><span class="keyword">val</span> expect_normal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../Trace/Instr/index.html#type-t">Trace.Instr.t</a></code></dt><dd><p>Return the <span class="xref-unresolved" title="unresolved reference to &quot;Instr.t&quot;"><code>Instr</code>.t</span> data of the instruction at address, and throw <code>Not_found</code> if the instruction was invalid</p></dd></dl><dl><dt class="spec value" id="val-get_normal_opt"><a href="#val-get_normal_opt" class="anchor"></a><code><span class="keyword">val</span> get_normal_opt : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><a href="../Trace/Instr/index.html#type-t">Trace.Instr.t</a> option</span></code></dt><dd><p>Return the <span class="xref-unresolved" title="unresolved reference to &quot;Instr.t&quot;"><code>Instr</code>.t</span> data of the instruction at address, and <code>None</code> if the instruction was invalid</p></dd></dl><dl><dt class="spec value" id="val-pp_slot"><a href="#val-pp_slot" class="anchor"></a><code><span class="keyword">val</span> pp_slot : <a href="index.html#type-slot">slot</a> <span>&#45;&gt;</span> PPrintEngine.document</code></dt><dd><p>Pretty prints a instruction slot</p></dd></dl><dl><dt class="spec value" id="val-pp_instr"><a href="#val-pp_instr" class="anchor"></a><code><span class="keyword">val</span> pp_instr : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Utils/index.html#module-Pp">Utils.Pp</a>.document</code></dt><dd><p>Dump instruction table</p></dd></dl></div></body></html>