<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Base (read-dwarf.Trace__.Base)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">read-dwarf</a> &#x00BB; <a href="../index.html">Trace__</a> &#x00BB; Base</nav><h1>Module <code>Trace__.Base</code></h1><nav class="toc"><ul><li><a href="#pretty-printing">Pretty printing</a></li><li><a href="#isla-to-trace-conversion">Isla to Trace conversion</a></li><li><a href="#trace-simplification">Trace simplification</a></li></ul></nav></header><aside><p>This module defines a new simplified kind of trace to replace Isla traces in the later stages of the instruction semantics processing.</p><p>The traces are even simpler and more easily typable. The possible events are in the type <a href="index.html#type-event"><code>event</code></a> and traces (<a href="index.html#type-t"><code>t</code></a>) are just list of them.</p><p>Compared to Isla, the concept of reading a register do not exist anymore. Nor the concept of pure symbolic variable or Sail structured values. Instead expression can contain only registers and results of previous memory read as decribe in the type <a href="Var/index.html#type-t"><code>Var.t</code></a>. All writing event directly write an entire expression. There are no intermediary variable definitions.</p><p>This raise a problem that if an isla trace reads a register after having written to it, then this is ambiguous to represent.</p><p>Thus a partially monadic representation has been chosen:</p><ul><li>The effect of writes on registers are delayed to the end, which means that registers variable value in every expression is the value of that register at the beginning of the trace. In particular, if there are two write to the register, only the last one have any effect, the other can be deleted.</li><li>The memory operation behave in normal monadic way, in particular a memory read can read the value written by a previous write in the same instruction, even if this is very unlikely.</li></ul><p>In the end, both assertion and register write to different registers can be reordered at will.</p><p>TODO: To make it more clean, getting register writes and assertions out of the trace would make sense like:</p><pre><code class="ml">type mem_event = Read of ... | Write of ...
type t = { asserts : exp list; reg_writes : (Reg.t * exp) list; mem: mem_event list }</code></pre><p>For all those reason, concatenating two trace semantically is very different that concatenating list of event, and is not implemented yet.</p><p>The important functions are <a href="index.html#val-of_isla"><code>of_isla</code></a> to convert and Isla traces and <a href="index.html#val-simplify"><code>simplify</code></a> for simplify traces.</p></aside><dl><dt class="spec module" id="module-Var"><a href="#module-Var" class="anchor"></a><code><span class="keyword">module</span> <a href="Var/index.html">Var</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>This module contains variable used in traces</p></dd></dl><dl><dt class="spec module" id="module-ExpPp"><a href="#module-ExpPp" class="anchor"></a><code><span class="keyword">module</span> ExpPp = <a href="../../Exp/index.html#module-Pp">Exp.Pp</a></code></dt><dd><p>A trace expression. No let bindings, no memory operations</p></dd></dl><div class="spec module" id="module-Typed"><a href="#module-Typed" class="anchor"></a><code><span class="keyword">module</span> Typed = <a href="../../Exp/index.html#module-Typed">Exp.Typed</a></code></div><div class="spec module" id="module-Exp"><a href="#module-Exp" class="anchor"></a><code><span class="keyword">module</span> <a href="Exp/index.html">Exp</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-exp"><a href="#type-exp" class="anchor"></a><code><span class="keyword">type</span> exp</code><code> = <a href="Exp/index.html#type-t">Exp.t</a></code></dt><dt class="spec type" id="type-event"><a href="#type-event" class="anchor"></a><code><span class="keyword">type</span> event</code><code> = </code><table class="variant"><tr id="type-event.WriteReg" class="anchored"><td class="def constructor"><a href="#type-event.WriteReg" class="anchor"></a><code>| </code><code><span class="constructor">WriteReg</span> <span class="keyword">of</span> </code><code>{</code><table class="record"><tr id="type-event.reg" class="anchored"><td class="def field"><a href="#type-event.reg" class="anchor"></a><code>reg : <a href="../../State/Reg/index.html#type-t">State.Reg.t</a>;</code></td></tr><tr id="type-event.value" class="anchored"><td class="def field"><a href="#type-event.value" class="anchor"></a><code>value : <a href="index.html#type-exp">exp</a>;</code></td></tr></table><code>}</code></td></tr><tr id="type-event.ReadMem" class="anchored"><td class="def constructor"><a href="#type-event.ReadMem" class="anchor"></a><code>| </code><code><span class="constructor">ReadMem</span> <span class="keyword">of</span> </code><code>{</code><table class="record"><tr id="type-event.addr" class="anchored"><td class="def field"><a href="#type-event.addr" class="anchor"></a><code>addr : <a href="index.html#type-exp">exp</a>;</code></td></tr><tr id="type-event.value" class="anchored"><td class="def field"><a href="#type-event.value" class="anchor"></a><code>value : int;</code></td></tr><tr id="type-event.size" class="anchored"><td class="def field"><a href="#type-event.size" class="anchor"></a><code>size : <a href="../../AstGen__Def/Size/index.html#type-t">Ast.Size.t</a>;</code></td></tr></table><code>}</code></td></tr><tr id="type-event.WriteMem" class="anchored"><td class="def constructor"><a href="#type-event.WriteMem" class="anchor"></a><code>| </code><code><span class="constructor">WriteMem</span> <span class="keyword">of</span> </code><code>{</code><table class="record"><tr id="type-event.addr" class="anchored"><td class="def field"><a href="#type-event.addr" class="anchor"></a><code>addr : <a href="index.html#type-exp">exp</a>;</code></td></tr><tr id="type-event.value" class="anchored"><td class="def field"><a href="#type-event.value" class="anchor"></a><code>value : <a href="index.html#type-exp">exp</a>;</code></td></tr><tr id="type-event.size" class="anchored"><td class="def field"><a href="#type-event.size" class="anchor"></a><code>size : <a href="../../AstGen__Def/Size/index.html#type-t">Ast.Size.t</a>;</code></td></tr></table><code>}</code></td></tr><tr id="type-event.Assert" class="anchored"><td class="def constructor"><a href="#type-event.Assert" class="anchor"></a><code>| </code><code><span class="constructor">Assert</span> <span class="keyword">of</span> <a href="index.html#type-exp">exp</a></code></td></tr></table></dt><dd><p>The event type. See the <a href="../../Trace/index.html"><span>module description</span></a> for more details</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = <span><a href="index.html#type-event">event</a> list</span></code></dt></dl><dl><dt class="spec value" id="val-iter_var"><a href="#val-iter_var" class="anchor"></a><code><span class="keyword">val</span> iter_var : <span>(<a href="Exp/index.html#type-var">Exp.var</a> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><a href="index.html#type-event">event</a> list</span> <span>&#45;&gt;</span> unit</code></dt></dl><section><header><h2 id="pretty-printing"><a href="#pretty-printing" class="anchor"></a>Pretty printing</h2></header><dl><dt class="spec value" id="val-pp_exp"><a href="#val-pp_exp" class="anchor"></a><code><span class="keyword">val</span> pp_exp : <span><span>(<span class="type-var">'a</span>, <a href="Var/index.html#type-t">Var.t</a>, <a href="../../Ast/index.html#type-no">Ast.no</a>, <a href="../../Ast/index.html#type-no">Ast.no</a>)</span> <a href="../../Ast/index.html#type-exp">Ast.exp</a></span> <span>&#45;&gt;</span> <a href="../../Utils/index.html#module-Pp">Utils.Pp</a>.document</code></dt><dd><p>Pretty print an expression</p></dd></dl><dl><dt class="spec value" id="val-pp_event"><a href="#val-pp_event" class="anchor"></a><code><span class="keyword">val</span> pp_event : <a href="index.html#type-event">event</a> <span>&#45;&gt;</span> <a href="../../Utils/index.html#module-Pp">Utils.Pp</a>.document</code></dt><dd><p>Pretty print an event</p></dd></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <span><a href="index.html#type-event">event</a> list</span> <span>&#45;&gt;</span> PPrintEngine.document</code></dt><dd><p>Pretty print a trace</p></dd></dl></section><section><header><h2 id="isla-to-trace-conversion"><a href="#isla-to-trace-conversion" class="anchor"></a>Isla to Trace conversion</h2><p>This section perform the conversion from Isla trace to the traces of this module.</p><p>The conversion is generrally obvious, however there is subtlety: If the Isla trace reads a register after having written it, then the read produce the written expression instead of just the symbolic value of that register. That why there is a <code>written_registers</code> parameter to some function of this section.</p></header><dl><dt class="spec exception" id="exception-OfIslaError"><a href="#exception-OfIslaError" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">OfIslaError</span></code></dt><dd><p>Throw an error in case of local conversion error. Normally a type-checked Isla trace should not fail in this section</p></dd></dl><dl><dt class="spec type" id="type-value_context"><a href="#type-value_context" class="anchor"></a><code><span class="keyword">type</span> value_context</code><code> = <span><a href="index.html#type-exp">exp</a> <a href="../../Utils/HashVector/index.html#type-t">Utils.HashVector.t</a></span></code></dt><dd><p>The context mapping Isla variable numbers to trace expression</p></dd></dl><dl><dt class="spec value" id="val-get_var"><a href="#val-get_var" class="anchor"></a><code><span class="keyword">val</span> get_var : <span><span class="type-var">'a</span> <a href="../../Utils/HashVector/index.html#type-t">Utils.HashVector.t</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Get the exression of the variable at the index. Throw <a href="index.html#exception-OfIslaError"><code>OfIslaError</code></a> if the variable is not bound</p></dd></dl><dl><dt class="spec value" id="val-exp_conv_subst"><a href="#val-exp_conv_subst" class="anchor"></a><code><span class="keyword">val</span> exp_conv_subst : <a href="index.html#type-value_context">value_context</a> <span>&#45;&gt;</span> <a href="../../Isla/index.html#type-rexp">Isla.rexp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a></code></dt><dd><p>Convert an Isla expression to a <code>Trace</code> expression by replacing all Isla variable by their value in the context. Throw <a href="index.html#exception-OfIslaError"><code>OfIslaError</code></a> if the substitution fails</p></dd></dl><dl><dt class="spec value" id="val-exp_of_valu"><a href="#val-exp_of_valu" class="anchor"></a><code><span class="keyword">val</span> exp_of_valu : Isla_lang.AST.lrng <span>&#45;&gt;</span> <span><a href="index.html#type-exp">exp</a> <a href="../../Utils/HashVector/index.html#type-t">Utils.HashVector.t</a></span> <span>&#45;&gt;</span> <a href="../../Isla/index.html">Isla</a>.valu <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a></code></dt><dd><p>Convert an <span class="xref-unresolved" title="unresolved reference to &quot;Isla.valu&quot;"><a href="../../Isla/index.html"><code>Isla</code></a>.valu</span> in a expression</p></dd></dl><dl><dt class="spec value" id="val-write_to_valu"><a href="#val-write_to_valu" class="anchor"></a><code><span class="keyword">val</span> write_to_valu : <span><span class="type-var">'a</span> <a href="../../Utils/HashVector/index.html#type-t">Utils.HashVector.t</a></span> <span>&#45;&gt;</span> <a href="../../Isla/index.html">Isla</a>.valu <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Write an expression to an <span class="xref-unresolved" title="unresolved reference to &quot;Isla.valu&quot;"><a href="../../Isla/index.html"><code>Isla</code></a>.valu</span></p></dd></dl><dl><dt class="spec value" id="val-event_of_isla"><a href="#val-event_of_isla" class="anchor"></a><code><span class="keyword">val</span> event_of_isla : <span>written_registers:<span><span>(<a href="../../State/Reg/index.html#type-t">State.Reg.t</a>, <a href="index.html#type-exp">exp</a>)</span> Stdlib.Hashtbl.t</span></span> <span>&#45;&gt;</span> <span>read_counter:<a href="../../Utils/Counter/index.html#type-t">Utils.Counter.t</a></span> <span>&#45;&gt;</span> <span>vc:<a href="index.html#type-value_context">value_context</a></span> <span>&#45;&gt;</span> <a href="../../Isla/index.html#type-revent">Isla.revent</a> <span>&#45;&gt;</span> <span><a href="index.html#type-event">event</a> option</span></code></dt><dd><p>Convert an isla event to optionally a Trace event, most events are deleted</p></dd></dl><dl><dt class="spec value" id="val-of_isla"><a href="#val-of_isla" class="anchor"></a><code><span class="keyword">val</span> of_isla : <a href="../../Isla/index.html#type-rtrc">Isla.rtrc</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Top level function to convert an isla trace to one of this module</p></dd></dl></section><section><header><h2 id="trace-simplification"><a href="#trace-simplification" class="anchor"></a>Trace simplification</h2></header><dl><dt class="spec module" id="module-SimpContext"><a href="#module-SimpContext" class="anchor"></a><code><span class="keyword">module</span> <a href="SimpContext/index.html">SimpContext</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A instance of <a href="../../Z3/ContextCounter/index.html"><code>Z3.ContextCounter</code></a>.</p></dd></dl><div class="spec module" id="module-Z3Tr"><a href="#module-Z3Tr" class="anchor"></a><code><span class="keyword">module</span> <a href="Z3Tr/index.html">Z3Tr</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-VarTbl"><a href="#module-VarTbl" class="anchor"></a><code><span class="keyword">module</span> <a href="VarTbl/index.html">VarTbl</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-declare_non_det"><a href="#val-declare_non_det" class="anchor"></a><code><span class="keyword">val</span> declare_non_det : <a href="../../Z3/index.html#type-server">Z3.server</a> <span>&#45;&gt;</span> <span><a href="index.html#type-event">event</a> list</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-simplify"><a href="#val-simplify" class="anchor"></a><code><span class="keyword">val</span> simplify : <span><a href="index.html#type-event">event</a> list</span> <span>&#45;&gt;</span> <span><a href="index.html#type-event">event</a> list</span></code></dt><dd><p>Simplify a trace by using Z3. Perform both local expression simplification and global assertion removal (when an assertion is always true)</p></dd></dl></section></div></body></html>